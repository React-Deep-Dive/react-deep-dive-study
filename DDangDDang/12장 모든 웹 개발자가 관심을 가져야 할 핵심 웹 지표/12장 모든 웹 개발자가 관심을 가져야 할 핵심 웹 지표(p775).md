
## 12.1 웹사이트와 성능(p775-790)

사용자가 웹 사이트에 접속했을 때 공통적으로 기대하는 사항 
1. 웹사이트를 방문한 목적을 손쉽게 달성할 수 있어야
2. 첫 번째 목적을 달성하는 데 걸리는 시간이 짧아야 
3. 웹사이트에서 개인정보가 누출되는 등의 사고 없이 보안이 철저해야

이 세가지만 달성할 수 있다면 웹사이트가 내부적으로 어떤 코드로 어떻게 이뤄져 있는지는 고객들에게 전혀 중요하지 않다.  

그러나 많은 개발자들이 이러한 성능에 대해 크게 관심을 기울이지 않는 것 또한 사실이다.  
왜냐하면  
1. 개발자의 기기는 대부분 일반적인 사용자의 평균적인 기기보다 성능이 뛰어나기 때문에 이러한 문제를 대체로 느끼지 못한다는 점
2. 능을 개선하는 작업은 새로운 기능을 개발하는 것보다 쉽지도 재밌지도 않고, 서비스를 개발하는 작업 대비 눈에 띄는 성능 향상을 기대하기도 어렵다는 점  

## 12.2 핵심 웹 지표란(p779-794)
핵심 웹 지표(Core Web Vital)란 구글에서 만든 지표로, 웹사이트에서 뛰어난 사용자 경험을 제공하는 데 필수적인 지표를 일컫는 용어

구글에서 핵심 웹 지표로 꼽는 지표는 다음과 같다.

- 최대 콘텐츠풀 페인트(LCP: Largest Contentful Paint)
- 최초 입력 지연(FID: First Input Delay)
- 누적 레이아웃 이동(CLS: Cumulative Layout Shift)

그리고 다음 두 지표는 핵심까지는 아니지만, 특정 문제를 진단하는 데 사용될 수 있다고 언급했다.  

- 최초 바이트까지의 시간(TTFB: Time To First Byte)
- 최초 콘텐츠풀 시간(FCP: First Contentful Paint)

## 12.3 최대 콘텐츠풀 페인트(LCP)(p780-795)
최대 콘텐츠풀 페인트(LCP: Largest Contentful Paint)란 페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간을 말한다.  

뷰포트는 사용자에게 현재 노출되는 화면을 의미한다. 사용자에게 노출되는 영역은 기기에 의존하므로 뷰포트 크기는 기기마다 다르다.   

이 뷰포트 내부에서 '큰 이미지와 텍스트'는 다음과 같다.
- `<img>`
- `<svg>` 내부의 `<image>`
- poster 속성을 사용하는 `<video>`
- url()을 통해 불러온 배경 이미지가 있는요소
- 텍스트와 같이 인라인 텍스트요소를 포함하고 있는 블록 레벨 요소   
    이 블록 레벨 요소에는 `<p>`, `<div>` 등이 포함된다.

이미지와 텍스트가 사용자의 시점에 언제 노출됐는지는 각 엘리먼트가 등장한 시점부터 텍스트 또는 이미지가 완전히 로딩되는 시점으로 보면 된다.  

즉, 최대 콘텐츠풀 페인트란 사용자의 기기가 노출하는 뷰포트 내부에서 가장 큰 영역을 차지하는 요소가 렌더링되는 데 얼마나걸리는지를 측정하는 지표인 것이다. 이 가장 큰 요소로 고려되는것은 앞의 5개이며, 실제 크기가 크다고 하더라도 뷰포트 영역 밖에 넘치는 요소가 있다면 해당 영역의 크기는 고려되지 않는다. 따라서 아무리 콘텐츠 높이가 길어도 최대 콘텐츠풀 페인트에 영향을 미치는 부분은 오직 뷰포트 영역뿐이다.  

### 12.3.2 의미(p781-796) 
단순히 사용자에게 있어 로딩이란 일단 뷰포트 영역에 보이는 부분을 기준으로 할 것이므로 뷰포트에 메인 콘텐츠가 화면에 완전히 전달되는 속도를 기준으로 한다면 사용자는 페이지가 로딩이 완료됐다고 체감하는 시간과 매우 비슷하게 측정할 수 있을 것이다. 따라서 사용자에게 페이지의 정보를 화면에 전달하는 속도를 객관적으로 판단하기 위한 지표로 만들어진 것이 바로 최대 콘텐츠풀 페인트(LCP)다.

### 12.3.4 기준 점수(p782-797)
최대 콘텐츠풀 페인트에서 좋은 점수란 해당 지표가 2.5초 내로 응답이 오는 것이다. 4초 이내로 응답이 온다면 보통, 그 이상이 걸리면 나쁨으로 판단  

### 12.3.5 개선 방안(p783-798)

#### 텍스트는 언제나 옳다 
좋은 점수를 얻는 가장 확실한 방법은 뷰포트 최대 영역, 즉 최대 콘텐츠풀 페인트 예상 영역에 이미지가 아닌 문자열을 넣는 것이다.  

#### 이미지는 어떻게 불러올 것인가?
```html 
<!-- 1) img -->
<img src="lcp.jpg" ... />
<!-- 2) svg -->
<svg xmlns="http://www.w3.org/1000/svg">
  <image href="lcp.jpg" /> 
</svg>
<!-- 3) (비디오의 경우) vide.poster --> 
<video poster="lcp.jpg"></video>
<!-- 4) background-image: url() -->
<div style="background-image:url(lcp.jpg)">...</div>
```
1번과 3번의 예제 코드가 더 빠르게 왼성된다.  

- `<img>`: 이미지는 브라우저의 프리로드 스캐너에 의해서 먼저 발견되어 빠르게 요청이 일어난다. 프리로드 스캐너란 HTML 파싱하는 단계를 차단하지 않고 이미지와 같이 빠르게 미리 로딩하면 좋은 리소스를 먼저 찾아 로딩하는 브라우저의 기능이다. `<img>` 내부의 리소스는 이처럼 HTML 파싱이 미처 완료되지 않더라도 프리로드 스캐너가 병렬적으로 리소스를 다운로드하므로 최대 콘텐츠풀 페인트 요소를 불러오기에 적절한 방법이다. 이는 `<picture>`도 마찬가지다.  
- `<svg>` 내부의 `<img>`: 이 방식은 프리로드 스캐너에 의해 발견되지 않아 병렬적으로 다운로드가 일어나지 않는다. 이는 결국 최대 콘텐츠풀 페인트 점수에도 악영향을 미치므로 이러한 방식은 삼가는 것이 좋다.  
- `<video>`의 poster: poster는 사용자가 video 요소를 재생하거나 탐색하기 전까지 노출되는 요소다. 이 역시 마찬가지로 프리로드 스캐너에 의해 조기에 발견되어 `<img>`와 같은 성능을 나타낸다. 그리고 한 가지 알아둬야 할 사실은 향후에 poster가 없는 video의 경우 video를 실제로 로딩해 첫 번째 프레임을 해당 poster 리소스로 대체할 예정이라는 것이다. 그러므로 video가 최대 콘텐츠풀 페인트에 영향을 받을 것 같다면 poster를 반드시 넣어주는 것이 좋다.
- `background-image: url()`: background-image를 비롯해서 CSS에 있는 리소스는 항상 느리다. 이러한 리소스는 브라우저가 해당 리소스를 필요로 하는 DOM을 그릴 준비가 될 때까지 리소스 요청을 뒤로 미루기 때문이다.   

## 12.4 최초 입력 지연(FID)(p788-803)
최초 입력 지연의 정의 : 사용자가 페이지와 처음 상호 작용할 때(예: 링크를 클릭하거나 버튼을 탭하거나 사용자 지정 JavaScript 기반 컨트롤을 사용할때)부터 해당 상호작용에  대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간을 측정합니다.  

온라인 예매 사이트나 대학교 수강 신청 페이지와 같이 순간적으로 몰린 트래필 때문에 웹사이트가 클릭이나 타이핑 되지 않는 경우가 있을 것이다.  
이처럼 아무리 빨리 로딩 되었다고 하더라도 웹사이트와 상호작용을 할 수 없다면 사용자는 웹사이트가 느리다고 생각할 것이다.    

이처럼 웹페이지의 로딩 속도만큼 중요한 것이 웹사이트의 반응 속도다. 그리고 이러한 웹사이트의 반응성을 측정하는 지표가 바로 최초 입력 지연(FID: First Input Delay)이다.  

### 12.4.2 의미  
웹 개발자들은 특별한 이유가 있는 경우를 제외하고 대부분의 사용자 입력에 대한 처리를 고의로 막거나 지연시키지 않는다.    

그럼에도 웹사이트 내부 이벤트의 반응이 늦어지는 이유는 대부분 해당 입력을 처리해야 하는 브라우저의 메인 스레드가 바쁘기 때문이다.  

메인 스레드가 바쁜 이유는 무언가 대규모 렌더링이 일어나고 있거나, 대규모 자바스크립트 파일을 분석하고 실행하는 등 다른 작업을 처리하는 데 리소스를 할애하고 있기 때문이다.  
이렇게 메인 스레드가 바쁜 경우, 자바스크립트 실행 환경은 '싱글 스레드'이기 때문에 자바스크립트가 이벤트 리스너와 같은 다른 작업을 실행할 수 없어 지연이 발생한다. 즉, 이벤트가 발생하는 시점에 최대한 메인 스레드가 다른 작업을 처리할 수 있도록 여유를 만들어 둬야 사용자에게 빠른 반응성을 보장할 수 있다.  

### 12.4.4 기준 점수(p790-805)
좋은 점수를 얻기 위해서는 100ms 이내로 응답이 와야 하며, 300ms 이내인 경우 보통, 그 이후의 경우에는 나쁨으로 처리

### 12.4.5 개선 방안(p791-806)
최초 입력 지연을 개선하려면 최초 입력 지연에 가장 큰 영향을 미치는 메인 스레드에 이벤트를 실행할 여유를 줘야 한다.   

#### 실행에 오래 걸리는 긴 작업을 분리
만약 실행에 오래 걸리는 작업이 있다면 아래의 대안을 고민해야 한다.
- 꼭 웹페이지에서 해야 하는 작업인가
- 긴 작업을 여러 개로 분리하기

#### 자바스크립트 코드 최소화(p793-808)

#### 타사 자바스크립트 코드 실행의 지연(p797-812)
사용자에게 안 좋은 반응성을 제공하는 타사 스크립트는 대부분 웹페이지 로드에 중요한 자원이 아니므로 `<script>`의 async와 defer를 이용해 지연 불러오기를 하는 것이 좋다.  

## 12.5 누적 레이아웃 이동(CLS)(p798-813)

### 12.5.1 정의 
웹사이트에서 로딩이 끝난 줄 알고 무언가를 클릭했는데 그 사이에 다른 요소가 로딩되면서 원래 클릭하려고 했던 요소를 클릭했던 경험이나, 내가 읽고 있던 무언가가 다른 요소의 출력으로 인해 사라졌던 경험들은 사용자가 원래 하려던 동작을 방해할 수도 있다.  
이처럼 페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표를 계산하는 것이 바로 누적 레이아웃 이동(CLS: Cumulative Layout Shift)이라고 한다.  

### 12.5.2 의미  
사용자가 보고 있던 콘텐츠의 위치가 배너로 인해 밀리거나 상호작용하려고 했던 요소의 위치가 바뀌면 상호작용에 실패하게 된다. 그래서 최초 렌더링 이후에 실행되는 이러한 영향을 끼치는 useEffect가 많을수록, 그리고 이 useEffect가 렌더링에 영향을 미칠수록 이 누적 레이아웃 이동에 좋지 못한 점수를 받을가능성이 커진다.  

### 12.5.5 개선 방안(p805-820)

#### 삽입이 예상되는 요소를 위한 추가적인 공간 확보
대부분의 큰 누적 레이아웃 이동은 클라이언트에서 삽입되는 동적인 요소로 인해 발생한다.  
이러한 영향을 받는 것을 미연에 방지하기 위해서는 useEffect의 내부에서 요소에 영향을 미치는 작업, 특히 뷰포트 내부에서 노출될 확률이 높은 작업을 최소화하는 것이 좋다.  

또한 무언가가 동적으로 뜰 것으로 예상되는 공간을 미리 확보해 두는 것도 좋은 방법이다.

#### 폰트 로딩 최적화 
누적 레이아웃 이동과 폰트 간에 큰 관계가 없다고 생각할 수도 있지만 폰트 또한 레이아웃 이동을 일으키는 원인 중 하나다.  

폰트로 인해 발생할 수 있는 문제는 크게 두 가지다.
- FOUT(flash of unstyled text): HTML문서에서 지정한 폰트가 보이지 않고 대체 기본폰트로 보이고 있다가 뒤늦게 폰트가 적용되는 현상
- FOIT(flash of invisible text): HTML 문서에서 지정한 폰트가 보이지 않고 기본 폰트도 없어서 텍스트가 없는 채로 있다가 뒤늦게 폰트가 로딩되면서 페이지에 렌더링되는 현상  

폰트는 각각 고유의 높이와 너비를 가지고 있다. 즉, 미처 지정한 폰트가 다운로드되기 전에 텍스트를 노출하려고 한다면 높이와 크기가 다른 기본 폰트를 기반으로 한 텍스트를 노출해서, 혹은 미처 텍스트를 노출하지 못해서 누적 레이아웃 이동이 발생할 수 있다.   

그래서 최대한 중요한 폰트의 다운로드를 우선순위에 밀어넣고, 이 우선순위를 활용했음에도 빠르게 로딩하는데 실패했다면 다음을 기약하고 기본 폰트를 노출해야 한다.  

### 12.5.6 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들(p809-824)  

- 최초 바이트까지의 시간(Time To First Byte, TTFB): 브라우저가 웹페이지의 첫 번째 바이트를 수신하는데 걸리는 시간을 의미. 즉, 페이지를 요청했을 때 요청이 완전히 완료되는 데 걸리는 시간을 측정하는것이 아니라 최초의 응답이 오는 바이트까지가 얼마나 걸리는지를 측정하는 지표.
- 최초 콘텐츠풀 페인트(First Contentful Paint, FCP): 페이지가 로드되기 시작한 시점부터 페이지 콘텐츠 의 일부가 화면에 렌더링될 때까지의 시간을 측정  
