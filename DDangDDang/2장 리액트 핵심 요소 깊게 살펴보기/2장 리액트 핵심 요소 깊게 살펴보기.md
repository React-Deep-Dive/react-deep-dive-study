
## 2.1 JSX란

- JSX는 XML 스타일의 트리구문을 간편하게 작성하게 한 문법(HTML, XML 외에도 확장될 수 있게 고려함)
- JSX는 리액트에 종송적이지 않은 독자적 문법이며, javascript 표준 코드도 아니다.
- JSX는 4가지 컴포넌트(JSXElement, JSXAttributes, JSXChildren, JSXString)로 구성된다.

#### JSXElement (p117)
JSX 구성의 가장 기본 요소.  
HTML의 요소(elemet)와 비슷한 역할

- JSXOpeningElement : `<JSXElement JSXAttributes(optional)>`
- JSXClosingElement : `<JSXElement />`
- JSXSelfClosingElement: `<JSXElement JSXAttributes(optional) />`
- JSXFragment : `<>JSXChildren(optional)</>`

##### 참고
리액트에서 HTML 구문 이외에 사용자가 정의한 컴포넌트는 반드시 대문자로 시작
현존하는 HTML 태그만 필터링해 처리하지 않고 위와 같은 규칙은 둔 이유는 미래에 추가되는 HTMl에 대한 가능성을 열어두고 확실하게 구별할 수 있는 차이점을 두기 위한 것으로 보인다.

#### JSXElementName
JSXELementName은 JSXElement의 요소 이름으로 쓸 수 있는 것을 의미

- JSXIdentifier : 식별자, `<$></$>`
	- 숫자, $, _ 외 다른 특수문자로 시작할 수 없다.
- JSXNamespacedName : `JSXIdentifier : JSXIdentifier`의 조합. `<foo:bar></foo:bar>`
	- 두개 이상 연결 불가 (`<foo:bar:baz></foo:bar:baz>` 불가)
- JSXMemberExpression : `JSXIdentifiler.JSXIdentifier`의 조합, `<foo.bar></foo:bar>`
	- 여러 개 이어서 가능, `<foo.bar.baz></foo.bar.baz>`

#### JSXAttributes
JSXAttributes는 JSXElement에 부여할 수 있는 속성

- JSXSpreadAttributes : 자바스크립트의 전개연산자와 동일한 역할
- JSXAttribute : 속성을 나타내는 키와 값. 키: JSXAttributeName, 값: JSXAttributeValue

#### JSXChildren
JSXChildren은 JSXElement의 자식값

#### JSXStrings

### 2.1.3 JSX는 어떻게 자바스크립트에서 변환될까 (p124)
`@babel/plugin-transform-react-jsx` 플러그인을 통해 JSX 구문을 자바스크립트가 이해할 수 있는 형태로 변환된 모습을 확인할 수 있다.

jsx가 변환되는 특성을 활용해 중복 코드를 최소화한 예시 (p126)
```jsx
// X props 여부에 따라 children 요소만 달라지는 경우
// 굳이 번거롭게 전체 내용을 삼항 연산자로 처리할 필요가 없다.
// 이 경우 불필요한 코드 중복이 일어난다.
import { createElement, PropsWithChildren } from 'react'

function TextOrHeading({
  isHeading,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return isHeading ? (
    <h1 className="text">{children}</h1>
  ) : (
    <span className="text">{children}</span>
  )
}

// O JSX가 변환되는 특성을 활용한다면 다음과 같이 간결하게 처리할 수 있다.
import { createElement } from 'react'

function TextOrHeading({
  isHeading,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return createElement(
    isHeading ? 'h1' : 'span',
    { className: 'text' },
    children,
  )
}
```

>[!info|normal] JSX 반환값이 결국 React.createElement로 귀결된다는 사실을 파악한다면 이런 식으로 쉽게 리팩터링할 수 있다.

### 2.1.4 정리(p127)
- 리액트에서만 JSX 가 쓰이는 것이 아니다 . Preact, SolidJS, NanoJSX 등 다양한 라이브러리도 JSX 를 채용하고 있다. 이 라이브러리들은 리액트와 다르게 JSXNamespacedName, JSXMeberExpression을 목적에 따라 사용할 수도 있으므로 이러한 스펙도 JSX문법임을 알아둬야 한다
- 리액트 내부에서 JSX 가 결국 자바스크립트 코드 createElement 로 번역된다는 것을 활용해 더 효율적인 코드를 작성할 수도 있다.

## 2.2 가상 DOM과 리액트 파이버 (p128)
리액트는 실제 DOM이 아닌 가상 DOM을 운영한다

이번 장에서 학습할 내용
- 가상 DOM이 무엇인지
- 실제 DOM에 비해 어떤 이점이 있는지
- 가상 DOM을 다룰때 주의할 점

### 2.2.1 DOM과 브라우저 렌더링 과정

브라우저가 웹사이트 접근 요청을 받고 화면을 그리는 과정
![[Pasted image 20240217032736.png]]

### 2.2.2 가상 DOM의 탄생 배경(131)

- 싱글 페이지 어플리케이션(SPA)는 하나의 페이지에서 모든 작업이 일어남으로 추가 랜더링 작업이 필요한 경우가 많다. 처음 랜더링이 되고 나서, 다양한 사용자의 인터렉션에 따라 DOM 의 변경으로 레이아웃과 리페인팅이 발생하면서 많은 비용이 든다.
- SPA의 라우팅이 변경되는 경우, 사이드바나 헤더 같은 요소를 제외하고 대부분의 요소를 삭제하고, 다시 삽입, 계산해야하는 작업이 들어간다.

>[!check|info] 여러번 발생할 렌더링 과정을 최소화 하고, 브라우저와 개발자의 부담을 덜어주기 위해 리액트에는 가상DOM 방식이 사용된다.

### 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버(p133) 

>[!bug|right] 꼭 다시 읽기!!

#### 리액트 파이버란?

리액트 파이버는 리액트에서 관리하는 평범한 자바스크립트 객체이다.
파이버는 파이버 재조정자(fiber reconciler)가 관리하는데, 이는 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하고 이 둘에 차이가 있으면 변경 정보를 갖고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.

재조정(reconcilation) : 리액트에서 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)

**리액트 파이버의 목표** :  리액트에서 발생하는 애니메이션, 레이아웃, 사용자 인터렉션의 반응성 문제를 해결하는 것

**리액트 파이버의 작업** : 파이버는 하나의 작업 단위로 구성되어있으며 스택조정자와 다르게 비동기적으로 수행한다. 다음과 같은 작업을 한다.
- 작업을 작은 단위로 분할하고 우선순위를 매길 수 있다.
- 작업을 멈추고, 재시작할 수 있다.
- 작업을 재사용하거나 버릴 수 있다.

#### 리액트 파이버 트리(p139)
리액트 내부에 두개의 파이버 트리가 존재한다. 
- 현재모습을 담은 current트리 
- 작업중인 상태를 나타내는 workInProgress 트리
리액트에서 업데이트 해야 할 사항이 발생되면, 새로운 workInProgress 트리를 생성한다. current 트리를 기준으로 workInProgress 트리가 빌드된다.
- setState와 같은 업데이트 작업은 시도때도 없이 일어나는데, 이때 기존에 있는 객체를 재활용해서 내부 속성값만 초기화하는 식으로 트리를 업데이트한다.
- 이 기존 트리를 순회해서 새로운 트리를 만드는 작업이 예전에 동기식으로 처리했다는 작업인데, 이제는 파이버단위로 비동기적으로 또 우선순위를 정해서 처리가 된다.
리액트 파이버의 작업이 끝나면, 리액트는 current 트리의 포인터를 workInProgress 트리로 가르키는 더블 버퍼링 기술을 사용해서 변경한다.
 - 더블 버퍼링: 컴퓨터 그래픽 분야 용어로 다음에 그려야할 그림을 미리 그린 후, 현재상태를 새로운 그림으로 바꾸는 기법이다.

#### 파이버 작업순서(p140)

1. beginWork() 함수를 실행해서 파이버 작업 수행 더 이상 자식이 없는 파이버를 만날때까지, 트리구조를 따라 beginWork()실행
    - 상태flag가 기록됨.
2. 자식이 없다면 completeWork() 실행
    - 트리가 빌드됨
3. 형제가 있다면 형제로 넘어가서 반복
4. 작업이 끝나면 return을 통해 작업완료를 알리고, 루트노드가 완성되면 최종적으로 commitWork() 가 수행되며, 변경사항을 비교해 업데이트가 필요한 사항이 DOM에 반영됨

## 2.4 렌더링은 어떻게 일어나는가?(p172)

### 2.4.1 리액트의 렌더링이란?

리액트에서 렌더링 : 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 자신이 갖고 있는 prop와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 과정

### 2.4.2 리액트의 렌더링이 일어나는 이유(p173)

리액트에서 렌더링이 발생하는 시나리오

1. 최초 랜더링 : 첫 어플리케이션 진입시 랜더링 할 결과물을 만들기 위해 최초 랜더링을 진행
2. 리랜더링
    - 클래스형 컴포넌트 리랜더링
        - setState 가 실행되는 경우
        - forceUpdate 가 실행되는 경우
    - 함수형 컴포넌트
        - useState 두번째 배열요소 setter 가 실행되는 경우
        - useReducer 두번째 벼열 요소인 dispatch 가 실행이 되는 경우
    - 컴포넌트 공통
        - key props 가 변경되는 경우
            > key 가 왜 필요한가 ?
            > - 형제 요소들 사이에서 동일한 요소를 식별하게 하는 값
            > - 리액트 파이버가 두 트리사이에서 리랜더링이 필요한 컴포넌트를 최소화하기 위해 key로 구별
            > - key 값이 바뀌면, 강제로 리랜더링을 일으키는 것이 가능
        - props 가 변경되는 경우
        - 부모 컴포넌트가 랜더링 되는 경우

### 2.4.3 리액트의 렌더링 프로세스 (p176)

렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서 내려가면서 업데이트가 필요하다고 지정된 모든 컴포넌트를 찾는다. 업데이트가 필요하다고 지정된 컴포넌트를 발견하면 각각 아래의 과정을 수행하고 그 결과물을 저장한다.
- 클래스형 컴포넌트 : 클래스 내부의 render() 함수 실행
- 함수형 컴포넌트 : FunctionComponent() 그 자체를 호출

### 2.4.4 렌더와 커밋(p177)

리액트의 랜더링은 랜더 단계와 커밋 단계 두단계로 분리되어 실행된다.

#### 렌더
컴포넌트를 실행해서 (render() 또는 return) 반환된 랜더링 결과물과 current fiber tree 를 비교해 변경이 필요한 컴포넌트를 체크해서 working fiber tree를 만듭니다.
type, props, key 가 다르면 변경이 필요한 컴포넌트로 체크된다.

#### 커밋
랜더 단계의 변경사항을 실제 DOM 에 적용해 사용자에게 보여준다.
리액트 내부의 참조를 업데이트해서 working fiber tree 를 current tree로 변경 한다.

>[!check|info] 랜더링이 일어난다고 무조건 DOM 업데이트가 일어나지 않는다. 랜더링을 수행해도 커밋 이 필요 없으면, 커밋 단계는 생략이 가능하다.


## 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션(p182)

### 2.5.1 주장 1: 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자(p183)

메모이제이션도 어디까지나 비용이 드는 작업이다!
- 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업
- 이전 결과물을 저장해 두었다가 다시 꺼내와야 하는 비용
이 두가지 비용이 있다.

이 비용이 리렌더링 비용보다 저렴한지 고민해야 한다.
상황에 따라 다르기에 섣부른 최적화를 경계해라

### 2.5.2 주장 2: 렌더링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자(p185)

일부 컴포넌트는 메모이제이션을 하는 것이 성능에 도움이 된다

memo를 컴포넌트의 사용에 따라 잘 살펴보고 일부에만 적용하는 방법
→ 개발자가 많아지고 컴포넌트의 복잡성이 증가하면 이 방법은 적용할 수 없다

memo를 일단 그냥 다 적용하는 방법
→ 적절하지 않은 컴포넌트에 memo를 적용했을 때 지불해야하는 비용은 props에 대한 얕은 비교뿐

반면 memo를 하지 않았을 때의 문제점
- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 그리구 위 두가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
- 리액트가 구 트리와 신 트리를 비교

따라서 최적화에 대한 확신이 없다면 가능한 모든 곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.

