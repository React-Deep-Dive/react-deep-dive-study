## 11.1 app 디렉터리의 등장(p715-730)

### 11.1.1 라우팅(p719-734)
Next.js13에서는 기존 `/pages`로 정의하던 라우팅 방식이 `/app`으로 이동했다.  
그리고 파일명으로 라우팅하는 것이 불가능해졌다.  

#### 라우팅을 정의하는 법
Next.js의 라우팅은 파일 시스템을 기반으로 하고 있다.  

- Next.js 12 이하: /pages/a/b.tsx 또는 /pages/a/b/index.tsx는 모두 동일한 주소로 변환된다. 즉, 파일명이 index라면 이 내용은 무시된다.  
- Next.js 13 app: /app/a/b는 /a/b로 변환되며, 파일명은 무시된다. 폴더명까지만 주소로 변환된다. 즉, app 디렉터리 내부의 파일명은 라우팅 명칭에 아무런 영향을 미치지 못한다.  

#### layout.js 
Next.js 13부터는 app 디렉터리 내부의 폴더명이 라우팅이 되며, 이 폴더에 포함될 수 있는 파일명은 몇 가지로 제한돼 있다.그중 하나가 layout.js다.    
이 layout.js는 페이지의 기본적인 레이아웃을 구성하는 요소이다.  
해당 폴더에 layout이 있다면 그 하위 폴더 및 주소에 모든 영향을 미친다.  

예
```tsx
// app/layout.tsx
import { ReactNode } from 'react'

export default function AppLayout({ children }: { children: ReactNode }) {
  return (
    <html lang="ko">
      <head>
        <title>안녕하세요!</title>
      </head>
      <body>
        <h1>웹페이지에 오신 것을 환영합니다.</h1>
        <main>{children}</main>
      </body>
    </html>
  )
}

// app/blog/layout.tsx
import { ReactNode } from 'react'

export default function BlogLayout({ children }: { children: ReactNode }) {
  return <section>{children}</section>
}
```

페이지 하위에 추가되는 layout은 해당 주소 하위에만 적용된다.  
이 레이아웃을 활용하면 다음과 같은 결과가 나올 것이다.  

```tsx 
<html lang="ko">
  <body>
    <h1>웹페이지에 오신 것을 환영합니다.</h1>
    <main><section>블로그 글</section></main>
  </body>
</html>
```

layout에서의 주의점은 다음과 같다.

- Layout은 app 디렉터리 내부에서는 예약어다. 무조건 `layout.{js|jsx|ts|tsx}`로 사용해야 하며, 레이아웃 이외의 다른 목적으로는 사용할 수 없다.  
- layout은 children을 props로 받아서 렌더링해야 한다. 레이아웃이므로 당연히 그려야할 컴포넌트를 외부에서 주입받고 그려야한다.  
- Layout 내부에는 반드시 export default로 내보내는 컴포넌트가 있어야 한다.
- layout 내부에서도 API 요청과 같은 비동기 작업을 수행할 수 있다.

#### page.js(p723-738) 
layout과 마찬가지로 page도 예약어이다.  
이전까지 Next.js에서 일반적으로 다뤘던 페이지를 의미한다.  

page가 받는 props는 다음과 같다.

- params: 옵셔널 값으로 앞서 설명한 `[...id]`와 같은 동적 라우트 파라미터를 사용할 경우 해당 파라미터에 값이 들어온다.  
- searchParams: URL에서 `?a=1`과 같은 URLSearchParams를 의미.(`?a=1&b=2`의 경우 searchParams에는 `{a:'1', b:'2'}`객체가 온다.) 참고로 이 값은 layout에서는 제공되지 않는다. 그래서 search parameter에 의존적인 작업을 하는 경우는 반드시 page 내부에서 수행해야 한다.  

page의 규칙은 다음과 같다.  

- page도 역시 app 디렉터리 내부의 예약어다.무조건 `page.{js|jsx|ts|tsx}`로사용해야 하며, 레이아웃 이외의 다른 목적으로는 사용할 수 없다.
- page도 역시 내부에서 반드시 export default로 내보내는 컴포넌트가 있어야 한다.

#### error.js(p724-739)
error.js는 해당 라우팅 영역에서 사용되는 공통 에러 컴포넌트다. error.js를 사용하면 특정 라우팅별로 서로 다른 에러 UI를 렌더링하는 것이 가능해진다.  

#### not-found.js(p725-740)
특정 라우팅 하위의 주소를 찾을 수 없는 404 페이지를 렌더링할 때 사용

#### loading.js 
리액트 Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용

#### route.js 
Next.js 13.4.0에서 app 디렉터리가 정식으로 출시되면서 이전까지 지원하지 못했던 `/pages/api`에 대한 `/app` 디렉터리 내부의 지원도 추가됐다. `/pages/api`와 동일하게 `/app/api`를 기준으로 디렉터리 라우팅을 지원하며, 앞서 파일명에 대한 라우팅이 없어진 것과 마찬가지로 `/api`에 대해서도 파일명 라우팅이 없어졌다.  
대신 디렉터리가 라우팅 주소를 담당하며 파일명은 route.js로 통일됐다.

## 11.2 리액트 서버 컴포넌트(p728-743)
리액트 18에서 새로 도입된 리액트 서버 컴포넌트는 서버 사이드 렌더링과 완전히 다른 개념이다. 두 용어 모두 '서버'라는 단어가 포함돼 있어 혼동의 여지가 있지만 '서버'라는 단어가 있다는 점, 그리고 '서버'에서 무언가 작업을 수행한다는 점을 제외하면 완전히 다른 개념으로 보는 것이 옳다.

### 11.2.1 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계
- 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없다.
- 백엔드 리소스에 대한 직접적인 접근이 불가능하다.
- 자동 코드 분할이 불가능하다.
- 연쇄적으로 발생하는 클라이언트와 서버의 요청을 다응하기 어렵다. 
- 추상화에 드는 비용이 증가한다.

서버 사이드 렌더링은 정적 콘텐츠를 빠르게 제공하고, 서버에 있는 데이터에 손쉽게 제공할 수 있는 반면 사용자의 인터랙션에 따른 다양한 사용자 경험을 제공하긴 어렵다.  
클라이언트 사이드 렌더링은 사용자의 인터랙션에 따라 정말 다양한 것들을 제공할 수 있지만 서버에 비해 느리고 데이터를 가져오는 것도 어렵다.  
이러한 두 구조의 장점을 모두 취하고자 하는 것이 바로 리액트 서버 컴포넌트다.

### 11.2.2 서버 컴포넌트란?(p732-747)
서버 컴포넌트(ServerComponent)란 하나의 언어, 하나의 프레임워크, 그리고 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법을 의미한다.  
서버에서 할 수 있는 일은 서버가 처리고, 서버가 할 수 없는 나머지 작업은 클라이언트(브라우저)에서 수행된다.  

다만 여기서 중요한 클라이언트 컴포넌트는 서버 컴포넌트를 import할 수 없다는 것이다.  
만약 클라이언트 컴포넌트가 서버 컴포넌트를 불러오게 된다면 클라이언트 컴포넌트는 서버 컴포넌트를 실행할 방법이 없기 때문에 컴포넌트를 호출할 수 없다.  

다만, 아래와 같은 방식으로 클라이언트 및 서버 컴포넌트가 혼재된 상황을 구현할 수 있다.(children으로 자주 사용되는 ReactNode를 사용해)  
```tsx
// ClientComponent.jsx
'use client'
// 이렇게 클라이언트 컴포넌트에서 서버 컴포넌트를 불러오는 것을 불가능하다.  
import ServerComponent from './ServerComponent.server'
export default function ClientComponent() {
  return (
    <div>
      <ServerComponent />
    </div>
  )
}
'use client'
// ClientComponent.jsx
export default function ClientComponent({ children }) {
  return (
    <div>
      <h1>클라이언트 컴포넌트</h1>
      {children}
    </div>
  )
}

// ServerComponent.jsx 
export default function ServerComponent() {
  return <span>서버 컴포넌트</span>
}

// ParentServerComponent.jsx
// 이 컴포넌트는 서버 컴포넌트일 수도, 클라이언트 컴포넌트일 수도 있다.  
// 따라서 두 군데 모두에서 사용할 수 있다.  
import ClientComponent from './ClientComponent'
import ServerComponent from './ServerComponent'
export default function ParentServerComponent() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  )
}
```
이 코드는 리액트 서버 컴포넌트를 기반으로 리액트 컴포넌트 트리를 설계할 때 어떠한 제한이 생기는지를 나타낸다.  
여기에는 서버 컴포넌트와 클라이언트 컴포넌트가 있으며 동시에 두 군데에서 모두 사용할 수 있는 공용 컴포넌트가 있다.

- 서버 컴포넌트 
    - 요청이 오면 그 순간 서버에서 딱 한 번 실행될 뿐이므로 상태를 가질 수 없다. 따라서 리액트에서 상태를 가질 수 있는 useState, useReducer 등의 훅을 사용할 수 없다.
    - 렌더링 생명주기도 사용할 수 없다. 한번 렌더링되면 그걸로 끝이기 때문이다. 따라서 useEffect, useLayoutEffect 를사용할수없다.
    - 앞의 두 가지 제약사항으로 인해 effect나 state에 의존하는 사용자 정의 훅 또한 사용할 수 없다. 다만 effect나 state 의존하지 않고 서버에서 제공할 수 있는 기능만 사용하는 훅이라면 충분히 사용 가능하다.
    - 브라우저에서 실행되지 않고 서버에서만 실행되기 때문에 DOM API를 쓰거나 window, document 등에 접근할 수 없다.  
    - 데이터베이스 내부서비스, 파일 시스템 등 서버에만 있는 데이터를 async/await으로 접근할 수 있다. 컴포넌트 자체가 async한 것이 가능하다.
    - 다른서버 컴포넌트를 렌더링하거나 div, span, p 같은 요소를 렌더링하거나, 혹은 클라이언트컴포넌트를 렌더링할 수 있다.
- 클라이언트 컴포넌트 
    - 브라우저 환경에서만 실행되므로 서버 컴포넌트를 불러오거나 서버 전용 혹이나 유틸리티를 불러올 수 없다.
    - 그러나 앞의 코드에서 본 것처럼 서버 컴포넌트가 클라이언트 컴포넌트를 렌더링하는데, 그 클라이언트 컴포넌트가 자식으로 서버 컴포넌트를 갖는 구조는 가능하다. 그 이유는 클라이언트 입장에서 봤을 때 서버 컴포넌트는 이미 서버에서 만들어진 트리를 가지고 있을 것이고 클라이언트 컴포넌트는 이미 서버에서 만들어진 그 트리를 삽입해서 보여주기만 하기 때문이다. 따라서 서버 컴포넌트와 클라이언트 컴포넌트를 중첩해서 갖는 위와 같은 구조로 설계하는 것이 가능하다.
    - 이 두 가지 예외 사항을 제외하면 일반적으로 우리가 알고 있는 리액트 컴포넌트와 같다.state와 effect를 사용할 수 있으며 브라우저 API도 사용할 수 있다.
- 공용 컴포넌트(shared components)
    - 이 컴포넌트는 서버와 클라이언트 모두에서 사용할 수 있다.공통으로 사용할 수 있는 만큼, 당연히 서버컴포넌트와 클라이언트 컴포넌트의 모든 제약을 받는 컴포넌트가 된다. 

리액트는 모든 것을 다 공용 컴포넌트로 판단한다.  
즉, 모든 컴포넌트를 다 서버에서 실행 가능한 것으로 분류한다.  
대신, 클라이언트 컴포넌트로 명시적으로 선언하려면 파일의 맨 첫 줄에 "use client"라고 작성하면 된다.  

### 11.2.4 서버 컴포넌트은 어떻게 작동하는가?(p737-752)

1. 서버가 렌더링 요청을 받는다. 서버가 렌더링 과정을 수행해야하므로 리액트 서버 컴포넌트를 사용하는 모든 페이지는 항상 서버에서 시작된다.즉, 루트에 있는 컴포넌트는 항상 서버 컴포넌트다.
2. 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화(serialize)한다. 이때 서버에서 렌더링할 수 있는 것은 직렬화해서 내보내고 클라이언트 컴포넌트로 표시된 부분은 해당 공간을 플레이스홀더 형식으로 비워두고 나타낸다. 브라우저는 이후에 이 결과물을 받아서 다시 역직렬화한 다음 렌더링을 수행한다.
3. 브라우저가 리액트 컴포넌트 트리를 구성한다.브라우저가 서버로 스트리밍으로 JSON 결과물을 받았다면 이 구문을 다시 파싱한 결과물을 바탕으로 트리를 재구성해 컴포넌트를 만들어 나간다. M1과 같은 형태의 클라이언트 컴포넌트를 받았다면 클라이언트에서 렌더링을 진행할 것이고 서버에서 만들어진 결과물을 받았다면 이 정보를 기반으로 리액트 트리를 그대로 만들 것이다. 그리고 최종적으로 이 트리를 렌더링해 브라우저의 DOM에 커밋한다.

## 11.3 Next.js에서의 리액트 브버 컴포넌트(p740-755)
Next.js가 13 버전을 릴리스하면서 서버 컴포넌트를 지원하기 시작했다.  
기본적인 서버 컴포넌트의 제약은 동일하다. 서버 컴포넌트는 클라이언트 컴포넌트를 불러올 수 없으며, 클라이언트 컴포넌트는 서버 컴포넌트를 children props로 받는 것만 가능하다.  
