# 11. Next.js 13과 리액트 18

리액트 18을 채택했으며, 기존에 Next.js의 약점으로 지적되던 레이아웃 지원을 본격적으로 지원하기 시작했고, 바벨을 대체할 러스트(Rust) 기반 SWC를 뒤이어 웹팩을 대체할 Turbopack까지 출시했다.

# 11.1 app 디렉터리의 등장

기존에는 페이지 공통으로 무언가를 집어 넣을 수 있는 곳은 \_document와 \_app이 유일했다.

- \_document: 페이지에서 쓰이는 <html>과 <body> 태그를 수정하거나, 서버 사이드 렌더링 시 styled-components와 같은 일부 CSS-in-JS를 지원하기 위한 코드를 삽입하는 제한적인 용도로 사용된다. 오직 서버에서만 작동하므로 onClick과 같은 이벤트 핸들러를 붙이거나 클라이언트 로직을 붙이는 것을 금지하고 있다.
- \_app: \_app은 페이지를 초기화하기 위한 용도로 사용되며, 다음과 같은 작업이 가능하다.
  - 페이지 변경 시에 유지하고 싶은 레이아웃
  - 페이지 변경 시 상태 유지
  - componentDidCatch를 활용한 에러 핸들링
  - 페이지간 추가적인 데이터 삽입
  - global CSS 주입
    \_app에서만 페이지 공통 레이아웃을 유지할 수 있었고, 각 페이지별로 서로 다른 레이아웃을 유지할 수 있는 여지가 부족하다. 레이아웃의 한계를 극복하기 위해 app 레이아웃이 나왔다.

## 11.1.1 라우팅

### 라우팅을 정의하는 법

app 기반 라우팅과 /pages의 차이

- Next.js 12 이하: /pages/a/b.tsx 또는 /pages/a/b/index.tsx는 모두 동일한 주소로 변환된다. 즉, 파일명이 index라면 이 내용은 무시된다.
- Next.js 13 app: /app/a/b는 /a/b로 변환되며, 파일명은 무시된다.

즉, Next.js 13의 app 디렉터리 내부의 파일명은 라우팅 명칭에 아무런 영향을 미치지 못한다.

### layout.js

Next.js 13부터는 app 디렉터리 내부의 폴더명이 라우팅이 되며, 이 폴더에 포함될 수 있는 파일명은 몇 가지로 제한돼 있다.

- 페이지의 기본적인 레이아웃을 구성하는 요소
- 해당 폴더에 layout이 있다면 그 하위 폴더 및 주소에 모두 영향을 미친다.
- layout은 주소별 공통 UI를 포함할 수 있을 뿐만 아니라 \_app과 \_document를 대신해 웹페이지를 시작하는 데 필요한 공통 코드를 삽입할 수도 있다.

### page.js

page는 layout을 기반으로 리액트 컴포넌트를 노출하게 된다.

page의 props

- params: 옵셔널 값으로 […id]와 같은 동적 라우트 파라미터를 사용할 경우 해당 파라미터에 값이 들어온다.
- searchParams: URL에서 ?a=1과 같은 URLSearchParams를 의미한다.
  - 이 값은 layout에서 제공되지 않는다. 이유는 layout은 페이지 탐색 중에는 리렌더링을 수행하지 않기 때문이다. 만약 search parameter에 의존적인 작업을 해야 한다면 반드시 page 내부에서 수행해야 한다.

### error.js

해당 라우팅 영역에서 사용되는 공통 에러 컴포넌트다. error.js를 사용하면 특정 라우팅별로 서로 다른 에러 UI를 렌더링하는 것이 가능해진다.

- 에러 바운더리는 클라이언트에서만 작동하므로 error 컴포넌트도 클라이언트 컴포넌트여야 한다.
- error 컴포넌트는 같은 수준의 layout에서 에러가 발생할 경우 해당 error 컴포넌트로 이동하지 않는다.

### not-found.js

### loading.js

리액트 Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용할 수 있다.

“use client” 지시자를 사용해 클라이언트에서 렌더링되게 할 수도 있다.

### route.js

Next.js 13.4.0에서 app 디렉터리가 정식으로 출시되면서 이전까지 지원하지 못했던 /pages/api에 대한 /app 디렉터리 내부의 지원도 추가됐다. /pages/api와 동일하게 /app/api를 기준으로 디렉터링 라우팅을 지원하며, /api에 대해서도 파일명 라우팅이 없어졌다.

그 대신 디렉터리가 라우팅 주소를 담다앟며 파일명은 route.js로 통일됐다.

- route 함수들이 받을 수 있는 파라미터
  - request: NextRequest 객체이며, fetch Request를 확장한 Next.js만의 Request이다. API 요청과 관련된 내용을 확인할 수 있다.
  - context: parmas만을 가지고 있는 객체이며, 동적 라우팅 파라미터 객체가 포함돼 있다.

# 11. 2 리액트 서버 컴포넌트

## 11.2.1 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

- 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없다.
- 백엔드 리소스에 대한 직접적인 접근이 불가능하다. 만약 클라이언트에서 직접 백엔드에 접근해 원하는 데이터를 가져올 수 있다면 어떨까?
- 자동 코드 분할(code split)이 불가능하다.
- 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다.
- 추상화에 드는 비용이 증가한다.
  - 일반적으로 웹 개발에서 템플릿 언어란 HTML에 특정 언어의 문법을 집어넣어 사용할 수 있는 것을 의미한다. 템플릿 언어는 HTML에서 할 수 없는 form 문이나 if 문 등을 처리할 수 있지만 그 밖의 복잡한 추상화나 함수 사용은 어렵다.

서버 사이드 렌더링의 한계점은 모든 문제가 리액트가 클라이언트 중심으로 돌아가기 때문에 발생하는 문제라는 것을 알 수 있다.

- 서버 사이드 렌더링과 클라이언트 렌더링의 두 구조의 장점을 모두 취하고자 하는 것이 리액트 서버 컴포넌트다.

## 11.2.2 서버 컴포넌트란?

하나의 언어, 하나의 프레임워크, 그리고 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링 할 수 있는 기법을 의미한다. 즉, 일부 컴포넌트는 클라이언트에서, 일부 컴포넌트는 서버에서 렌더링되는 것이다.

- 클라이언트는 서버 컴포넌트를 import 할 수 없다.

  서버 컴포넌트의 이론에 따르면 모든 컴포넌트는 서버 컴포넌트가 될 수도 있고 클라이언트 컴포넌트가 될 수도 있다. 이런 구조는 ReactNode에 달려 있다.

  ```jsx
  // ParentServerComponent.jsx
  import ClientComponent from './ClientComponent';
  import ServerComponent from './ServerComponent';
  export default function ParentServerComponent() {
    return (
      <ClientComponent>
        <ServerComponent />
      </ClientComponent>
    );
  }
  ```

  - 서버 컴포넌트
    - 상태를 가질 수 없다.
    - 렌더링 생명주기도 사용할 수 없다.
    - 상요자 정의 훅을 사용할 수 없다.
    - DOM API를 쓰거나 window, document 등에 접근할 수 없다.
  - 클라이언트 컴포넌트
    - 서버 전용 훅이나 유틸리티를 불러올 수 없다.
    - 클라이언트 컴포넌트가 자식으로 서버 컴포넌트를 갖는 구조는 가능하다.
  - 공용 컴포넌트
    - 서버 컴포넌트와 클라이언트 컴포넌트의 모든 제약을 받는 컴포넌트가 된다.

## 11.2.3 서버 사이드 렌더링과 서버 컴포넌트의 차이

서버 사이드 렌더링

- 목적 : 정적인 HTML을 빠르게 내려주는 데 초점을 두고 있다. 따라서 초기 HTML이 로딩된 이후에는 클라이언트에서 자바스크립트 코드를 다운로드하고, 파싱하고, 실행하는 데 비용이 든다.

둘은 대체재가 아닌 상호보완하는 개념으로 봐야 할 것 이다.

## 11.2.4 서버 컴포넌트는 어떻게 작동하는가?

1. 서버가 렌더링 요청을 받는다. 서버가 렌더링 과정을 수행해야 하므로 리액트 서버 컴포넌트를 사용하는 모든 페이지는 항상 서버에서 시작된다. 즉, 루트에 있는 컴포넌트는 항상 서버 컴포넌트다.
2. 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화한다. 서버에서 렌더링할 수 있는 것은 직렬화해서 내보내고, 클라이언트 컴포넌트로 표시된 부분은 해당 공간을 플레이스홀더 형식으로 비워두고 나타낸다. 브라우저는 이 결과물을 받아서 다시 역직렬화한 다음 렌더링을 수행한다.

리액트 서버 컴포넌트의 작동 방식의 특별한 점

서버 컴포넌트의 작동 바식

- 서버에서 클라이언트로 정보를 보낼 때 스트리밍 형태로 보냄으로써 클라이언트가 줄 단위로 JSON을 읽고 컴포넌트를 렌더링할 수 있어 브라우저에서는 되도록 빨리 사용자에게 결과물을 보여줄 수 있다는 장점이 있다.
- 또한 컴포넌트들이 하나의 번들러 작업에 포함돼 있지 않고 각 컴포넌트별로 번들리잉 별개로 되어 있어 필요에 따라 컴포넌트를 지연해서 받거나 따로 받는 등의 작업이 가능해졌다.
- 서버 사이드 렌더링과는 다르게 결과물이 HTML이 아닌 JSON 형태로 보내진다.

# 11.3 Next.js에서의 리액트 서버 컴포넌트

Next.js가 13 버전을 릴리즈하면서 서버 컴포넌트를 지원하기 시작했다.

page.js와 layout.js는 반드시 서버 컴포넌트여야 하며, 서버 컴포넌트의 제약을 받는다.

## 11.3.1 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

모든 데이터 요청은 웹에서 제공하는 표준 API인 fetch를 기반으로 이뤄진다.

getServerSideProps는 서버 사이드 렌더링만을 위한 것이었으므로 이제 서버에서 데이터를 직접 불러올 수 있게 됐다. 또한 컴포넌트가 비동기적으로 작동하는 것도 가능해진다.

추가로 리액트 팀은 fetch API를 확장해 서버 컴포넌트 트리 내에서 동일한 요청이 있다면 재요청이 발생하지 않도록 요청 중복을 방지했다.

## 11.3.2 정적 렌더링과 동적 렌더링

getStaticProps를 활용해 서버에서 불러오는 데이터가 변경되지 않는 경우에 정적으로 페이지를 만들어 제공할 수 있는 기능이 있었다. 이 기능을 활용하면 해당 주소로 들어오는 경우 모든 결과물이 동일하기 때문에 CDN에서 캐싱해 기존 서버 사이드 렌더링보다 더 빠르게 데이터를 제공할 수 있다는 장점이 있었다.

Next.js 13에서는 정적인 라우팅에 대해서는 기본적으로 빌드 타임에 렌더링을 미리 해두고 캐싱해 재사용할 수 있게끔 해뒀고, 동적인 라우팅에 대해서는 서버에 매번 요청이 올 때마다 컴포넌트를 렌더링 하도록 변경했다.

## 11.3.3 캐시과 mutating, 그리고 revalidating

해당 데이터의 유효한 시간을 정해두고 이 시간이 지나면 다시 데이터를 불러와서 페이지를 렌더링하는 것이 가능하다. 이는 페이지에 revalidate 라는 변수를 선언해서 페이지 레벨로 정의하는 것도 가능하다.

`router.refresh()`를 사용하면 캐시를 전체적으로 무효화할 수 있고, 브라우저나 리액트의 state에는 영향을 미치지 않는다.

## 11.3.4 스트리밍을 활용한 점진적인 페이지 불러오기

모든 작업이 순차적으로 다 완료돼야만 페이지 하나를 온전하게 볼 수 있던 단점을 극복하기 위해 HTML을 작은 단위로 쪼개서 완성되는 대로 클라이언트로 점진적으로 보내는 스트리밍이 도입됐다.

이는 사용자가 일부라도 페이지와 인터랙션을 할 수 있다는 것을 의미하며, 나아가 핵심 웹 지표인 최초 바이트까지의 시간(TTTB: Time To First Byte)과 최초 콘텐츠풀 페인팅(FCP: First Contentful Paint)을 개선하는데 도움을 준다.

# 11.4 웹팩의 대항마, 터보팩의 등장(beta)

# 11.5 서버 액션(alpha)

API를 굳이 생성하지 않아도 함수 수준에서 서버에 직접 접근해 데이터 요청을 수행할 수 있는 기능이다. 서버 컴포넌트와 다르게, 특정 함수 실행 그 자체만을 서버에서 수행할 수 있다는 장점이 있다.

## 11.5.1 form의 액션

서버 액션을 실행하면 클라이언트에서는 현재 라우트 주소와 ACTION_ID만 보내고 그 외에는 아무것도 실행하지 않는다. 그리고 서버에서는 요청받은 라우트 주소와 ACTION_ID를 바탕으로, 실행해야 할 내용을 찾고 이를 서버에서 직접 실행한다.

이 모든 과정은 새로고침 없이 데이터 스트리밍으로 이뤄진다. 따라서 개발자들은 서버에 데이터 수정을 요청하는 한편, 클라이언트에서는 사용자에게 로딩 중이라는 것을 알 수 있는 인터랙션을 구성할 수도 있다.

## 11.5.2 input의 submit과 image의 formAction

form.action과 마찬가지로 input type=”submit” 또는 input type=”image”에 formAction prop으로도 서버 액션을 추가할 수 있다.

## 11.5.3 startTransition과의 연동

useTransition에서 제공하는 startTransition에서도 서버 액션을 활용할 수 있다.

## 11.5.3 startTransition과의 연동

useTransition에서 제공하는 startTransition에서도 서버 액션을 활용할 수 있다.

## 11.5.3 startTransition과의 연동

useTransition에서 제공하는 startTransition에서도 서버 액션을 활용할 수 있다.

```tsx
// server-action/index.ts
'use server';

export async function updateData(
  id: string,
  data: { name: string; age: number }
) {
  const key = `test:${id}`;

  await kv.set(key, {
    name: data.name,
    age: data.age,
  });

  revalidatePath(`/server-action/form/${id}`);
}

// client-component.tsx
('use client');

export function ClientButtonComponent({ id }: { id: string }) {
  const [isPending, startTransition] = useTransition();

  const handleClick = useCallback(() => {
    startTransition(() => updateDate(id, { name: '기본값', age: 0 }));
  }, []);
}
```

## 11.5.4 server mutation이 없는 작업

server mutation이 필요하다면 반드시 서버 액션을 useTransition과 함께 사용해야 하지만 별도의 server mutation을 실행하지 않는다면 바로 이벤트 핸들러에 넣어도 된다.

## 11.5.5 서버 액션 사용 시 주의 할 점

- 서버 액션은 클라이언트 컴포넌트 내에서 정의될 수 없다. 클라이언트 컴포넌트에서 서버 액션을 쓰고 싶을 때는 ‘use server’로 서버 액션만 모여 있는 파일을 별도로 import해야 한다.
- 서버 액션을 import하는 것 뿐만 아니라, props 형태로 서버 액션을 클라이언트 컴포넌트에 넘기는 것 또한 가능하다. 이는 서버 컴포넌트가 클라이언트 컴포넌트를 불러올 수 있는 것과 동일한 원리다. 즉 서버에서만 실행될 수 있는 자원은 반드시 파일 단위로 분리해야 한다.

# 11.6 그 밖의 변화

프로젝트 전체 라우트에서 쓸 수 있는 미들웨어가 강화됐고, SEO(Search Engine Optimization)를 쉽게 작성할 수 있는 기능이 추가됐으며, 정적으로 내부 링크를 분석할 수 있는 기능 등 다양한 내용이 추가됐다.

# 11.7 Next.js 13 코드 맛보기

## 11.7.1 getServerSideProps와 비슷한 서버 사이드 렌더링 구현해 보기

이전 버전까지는 서버 관련 코드가 있다면 무조건 제한된 스코프 내에서만 실행이 가능했다. 그러나 Next.js 13과 리액트 18에서는 서버 컴포넌트라면 어디든 서버 관련 코드를 추가할 수 있게 됐다.

서버 컴포넌트에서 fetch를 수행하고, 이 fetch에 별다른 cache 옵션을 제공하지 않는다면 기존의 getServerSideProps와 매우 유사하게 작동한다.

즉, Next.js 13에서도 여전히 서버 사이드 렌더링과 비슷하게 서버에서 미리 페이지를 렌더링해서 내려받는 것이 가능하다.

과거 getServerSideProps를 사용하는 애플리케이션에서는 서버에서 만들어진 정보를 바탕으로 클라이언트에서 하이드레이션을 수행했었다. 리액트 18에서는 서버 컴포넌트에서 렌더링한 결과를 직렬화 가능한 데이터로 클라이언트에 제공하고, 클라이언트는 이를 바탕으로 하이드레이션을 진행하게 된다.

## 11.7.2 getStaticProps와 비슷한 정적인 페이지 렌더링 구현해 보기

Next.js 13 이전까지는 정적 페이지 생성을 위해 getStaticProps나 getStaticPaths를 이용해 사전에 미리 생성 가능한 경로(path)를 모아둔 다음, 이 경로에 내려줄 props를 미리 빌드하는 형식으로 구성돼 있었다. 이러한 방법은 헤드리스(headless) CMS 같이 사용자 요청에 앞서 미리 빌드해둘 수 있는 페이지를 생성하는 데 매우 효과적이었다.

Next.js 13에서 app 디렉터리가 생겨나면서 getStaticProps와 getStaticPaths는 사라졌지만 이와 유사한 방식을 fetch의 cache를 이용해 구현할 수 있다.

‘Incremental Static Regeneration’ : 정적으로 미리 빌드해 두는 것 뿐만 아니라 캐시를 활용하는 방식. 정적으로 생성된 페이지를 점진적으로 갱신하는 것을 의미한다. Next.js에서 제공하는 캐시와 관련된 기능을 활용하면 일정 기간 동안은 캐시를 통해 가져와 빠르게 렌더링하고, 시간이 지나면 새롭게 데이터를 불러오는 방식으로 페이지를 구성할 수 있다.

## 11.7.3 로딩, 스트리밍, 서스펜스

Next.js 13에서는 스트리밍(streaming)과 리액트의 서스펜스(suspense)를 활용해 컴포넌트가 렌더링 중이라는 것을 나타낼 수 있다. 직접 Suspense로 감싸 부분적으로 로딩을 보여주는 것 외에도 기본적으로 loading이라고 하는 파일 예약어를 지원하면서 손쉽게 로딩 라우팅별로 로딩 상태를 나타낼 수 있도록 제공한다. loading과 suspense 모두 동일한 방식으로 작동한다.

# 11.8 정리 및 주의사항
