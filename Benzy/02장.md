# 02. 리액트 핵심 요소 깊게 살펴보기

# 2.1 JSX란?

- JSX는 반드시 트랜스파일러를 거쳐야 자바스크립트 런타임이 이해할 수 있는 코드로 변환된다.
- JSX의 설계 목적
  - 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환하는 데 초점을 두고 있다. 즉, JSX는 HTML, XML 외에도 다른 구문으로 확장될 수 있게끔 고려되어 있다.

## **2.1.1 JSX의 정의**

JSX는 기본적으로 `JSXElement`, `JSXAttributes`, `JSXChildren`, `JSXStrings` 4가지 컴포넌트를 기반으로 구성돼 있다.

- `JSXElement`
  - HTML의 요소(element)와 비슷한 역할을 한다.
  - 리액트에서 HTML 태그명과 사용자가 만든 컴포넌트 태그명을 구문 짓기 위해 대문자로 시작하는 컴포넌트를 만들어야만 한다.
- `JSXElementName`
  `JSXElement`의 요소 이름으로 쓸 수 있는 것을 의미한다.
  - `JSXIdentifier` : JSX 내부에서 사용할 수 있는 식별자를 의미한다. 자바스크립트와 마찬가지로 숫자나 특수문자로는 시작할 수 없다.
  - `JSXNamespacedName` : `JSXIdentifier:JSXIdentifier`의 조합, 즉 `:`을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급된다.
    ```jsx
    function ComponentA() {
      return <A.B></A.B>;
    }
    ```
  - `JSXMemberExpression`: `JSXIdentifier.JSXIdentifier`의 조합
    ```jsx
    function ComponentC() {
    	return <A:B.C></A:B.C>
    }
    ```
- `JSXAttributes`
  `JSXElement`에 부여할 수 있는 속성을 의미한다. 모든 경우에서 필수값이 아니다.
  - `JSXSpreadAttributes`
  - `JSXAttribute`
  - `JSXAttributeValue`
  - `JSXFragment`
- `JSXChildren`
  JSXElement의 자식 값을 나타낸다.
- `JSXStrings`
  HTML에서 사용 가능한 문자열은 모두 JSXStrings에서도 사용 가능하다.

## **2.1.2 JSX 예제**

## **2.1.3 JSX는 어떻게 자바스크립트에서 변환될까?**

@babel-plugin-transform-react-jsx 플러그인이 JSX 구문을 자바스크립트가 이해할 수 있는 형태로 변환한다.

JSX 반환값이 결국 React.createElement로 귀결된다는 사실을 파악한다면 쉽게 리팩터링할 수 있다.

```tsx
function TextOrHeading({
  isHeading,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return isHeading ? (
    <h1 className='text'>{children}</h1>
  ) : (
    <span>{children}</span>
  );
}

// JSX가 변환되는 특성을 활용한다면 다음과 같이 간결하게 처리할 수 있다.
function TextOrHeading({
  isHeading,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return createElemet(
    isHeading ? 'h1' : 'span',
    { className: 'text' },
    children
  );
}
```

## 2.1.4 정리

JSX 문법에는 있지만 실제로 리액트에서 사용하지 않는 것은 다음과 같다.

- `JSXNamespacedName`, `JSXMemberExpression`

# 2.2 가상 DOM과 리액트 파이버

## **2.2.1 DOM과 브라우저 렌더링 과정**

DOM : 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.

HTML을 파싱하고, 스타일을 계산하고, 레이아웃, 페인팅 등이 차례로 일어나는 것을 볼 수 있다.

## **2.2.2 가상 DOM의 탄생 배경**

**가상 DOM이 필요한 이유**

- 브라우저가 웹페이지를 렌더링하는 과정은 매우 복잡하고 많은 비용이 든다. 또한 렌더링이 완료된 이후에도 사용자의 인터랙션으로 웹페이지가 변경되는 상황 또한 고려해야 한다.
- 렌더링 이후 추가 렌더링 작업은 하나의 페이지에서 모든 작업이 일어나는 싱글 페이지 애플리케이션에서 더욱 많아진다.
- 개발자는 인터랙션에 모든 DOM의 변경보다는 결과적으로 만들어지는 DOM 결과물이 필요하다.

**가상 DOM의 특징**

- 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영한다.
- 가상 DOM은 무조건 빠른 것이 아니라, 대부분의 상황에서 웬만한 애플리케이션을 만들 수 있을 정도로 충분히 빠르다는 것이다.

## **2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버**

가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 **리액트 파이버(React Fiber**)다.

### 리액트 파이버란?

- 리액트에서 관리하는 자바스크립트 객체
- 파이버 재조정자(fiber reconciler) : 파이버를 관리하는 역할
  - 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집한다.
  - 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청한다.
  - Reconcilation Algorithm : 리액트에서 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)
- 리액트 파이버의 목표 : 애니메이션, 레이아웃, 사용자 인터랙션에 올바른 결과물을 만드는 반응성 문제를 해결하는 것
  - 이를 위해 파이버는 다음과 같은 일을 할 수 있다.
    - 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다.
    - 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
    - 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우 폐기할 수 있다.
  - 위의 과정이 비동기로 일어난다.
    - 과거 리액틍 알고리즘은 스택 알고리즘으로 렌더링에 필요한 작업들이 쌓이면 스택이 빌 때까지 동기적으로 작업이 이루어졌다. → 리액트의 비효율성을 발생
- 파이버의 구현 원리
  - 파이버는 하나의 작업 단위로 구성돼 있다. 리액트는 이러한 작업 단위를 하나씩 처리하고 finishWork()라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만들어낸다.
    - 렌더 단계 : 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 그리고 이 단계에서 앞서 언급한 파이버의 작업, 우선순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어난다.
    - 커밋 단계 : DOM에 실제 변경 사항을 반영하기 위한 작업, `commitWork()`가 실행되는데, 이 과정은 앞서와 다르게 동기식으로 일어나고 중단될 수도 없다.
- 파이버는 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적이면 **재사용**된다.
- 파이버는 하나의 element에 하나가 생성되는 1:! 관계를 가지고 있다.(`tag`)
- 생성된 파이버는 state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점 등에 실행된다.
- 리액트의 핵심 원칙 : UI를 문자열, 숫자, 배열과 같은 값으로 관리한다는 것이다. 변수에 이러한 UI 관련 값을 보관하고, 리액트에 자바스크립트 코드 흐름에 따라 이를 관리하고, 표현하는 것이 리액트이다.

### 리액트 파이버 트리

- 파이버 트리는 리액트 내부에서 두 개가 존재한다.
  - 현재 모습을 담은 파이버 트리
  - 작업 중인 상태를 나타내는 workInProgress 트리
- 더블 버퍼링 : 리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 workInProgress 트리를 현재 트리로 바꿔버린다.
  - 더블 버퍼링은 커밋 단계에서 수행한다.

### 파이버의 작업 순서

- 파이버 노드의 생성 흐름

  1. 리액트의 `beginWork()` 함수 실행, 더 이상 작식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다.
  2. 1번에서 작업이 끝나면 `completeWork()`함수를 실행해 파이버 작업을 완료한다.
  3. 형제가 있다면 형제로 넘어간다.
  4. 2번 3번이 모두 끝났다면 return으로 돌아와 자신의 작업이 완료되었음을 알린다.

- setState 등으로 업데이트가 발생하는 경우 workInProgress 트리를 다시 빌드하기 시작한다. 파이버가 이미 존재하므로 되도록 새로 생성하지 않고 기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리한다.
- 과거에는 트리 업데이트 과정을 재귀적으로 순회하하여 동기식으로 처리했지만, 현재는 우선순위에 따라 일시 중단하거나 새롭게 만들거나 폐기할 수 있다.

## **2.2.4 파이버와 가상 DOM**

파이버는 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있다. 파이버는 리액트 아키텍처 내부에서 비동기로 이루어진다. 하지만 실제 DOM에 반영하는 것은 동기적으로 이루어야 하기에 메모리상에서 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용한다.

## 2.2.5 정리

가상 DOM과 리액트의 핵심은 브라우저의 DOM을 더욱 빠르게 반영하는 것이 아니라 값으로 UI를 표현하는 것이다.

# 2.3 클래스형 컴포넌트와 함수형 컴포넌트

## **2.3.1 클래스형 컴포넌트**

### 클래스형 컴포넌트의 생명주기 메서드

- 생명주기 메서드가 실행되는 시점
  - 마운트(mount): 컴포넌트가 마운팅(생성)되는 시점
  - 업데이트(update): 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
  - 언마운트(unmount): 컴포넌트가 더 이상 존재하지 않는 시점
- 생명주기 메서드

  - `render()` : 컴포넌트가 UI를 렌더링하기 위해서 쓰인다. 마운트와 업데이트 과정에서 일어난다.
    렌더 함수는 항상 순수해야 하며 부수 효과가 없어야 한다.
  - `componentDidMount()` : 클래스형 컴포넌트가 마운트되고 준비가 됐다면 그 다음으로 호출하는 생명주기 메서드이다. state 값을 변경하는 것이 가능하다.
  - `componentDidUpdate()`: 컴포넌트 업데이트가 일어난 이후 바로 실행된다.
  - `componentWillUnmound()`: 컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출된다.
  - `shouldComponentUpdate()`: 컴포넌트에 영향을 받지 않는 변화에 대해 정의할 수 있다.
    - Component와 PureComponent의 차이점이 이 생명주기를 다루는 데 있다. Component의 경우 state 값이 업데이트 되는 대로 렌더링이 일어나지만 PureComponent는 state 값에 대한 얕은 비교를 수행해 결과가 다를 때만 렌더링을 수행한다.
  - `static getDerivedStateFromProps()`: `componentWillReceiveProps`를 대체할 수 있는 메서드다. `render()`를 호출하기 직전에 호출된다. static으로 선언되어 있어 this에 접근할 수 없다.
  - `getSnapShotBeforeUpdate()`: `componentWillUpdate()`를 대체할 수 있는 메서드다. DOM이 업데이트되기 직전에 호출된다.

  - `getDerivedStateFromError()`: 자식 컴포넌트에서 에러가 발생했을 때 호출되는 메서드다.
  - `componentDidCatch()`: 자식 컴포넌트에서 에러가 발생했을 때 실행되며, getDerivedStateFromError에서 에러를 잡고 state를 결정한 이후에 실행된다.

  > getDerivedStateFromError() 메서드와 componentDidCatch() 메서드는 ErrorBoundary, 에러 경계 컴포넌트를 만들기 위한 목적으로 많이 사용된다.

  **ErrorBoundary에서 주의할 점**
  componentDidCatch는 개발 모드와 프로덕션 모드에서 다르게 작동한다. 개발 모드에서는 에러가 발생하면 window까지 전파된다. 그러나 프로덕션 모드에서는 componentDidCatch로 잡히지 않은 에러만 window까지 전파된다.

  >

- 클래스형 컴포넌트의 한계
  - 데이터의 흐름을 추적하기 어렵다. 서로 다른 여러 메서드에서 state 업데이트가 일어날 수 있으며, 코드 작성 시 메서드의 순서가 강제돼 있지 않아 가독성을 챙기기 어렵다.
  - 애플리케이션 내부 로직의 재사용이 어렵다.
  - 기능이 많아질수록 컴포넌트의 크기가 커진다.
  - 클래스는 함수에 비해 상대적으로 어렵다.
  - 코드 크기를 최적화하기 어렵다. (번들링을 최적화하기에 불리한 조건이다.) - 사용하지 않는 메서드도 쉐이킹외 되지 않고, 번들에 포함되기 때문
  - 핫 리로딩을 하는 데 상대적으로 불리하다.

## **2.3.2 함수형 컴포넌트**

16.8 버전 이전에는 단순히 무상태 컴포넌트를 구현하기 위한 수단이었지만, 훅이 등장하면서 각광받고 있다.

## **2.3.3 함수형 컴포넌트 vs. 클래스형 컴포넌트**

### 생명주기 메서드의 부재

- 함수형 컴포넌트는 props를 받아 단순히 리액트 요소만 반환하는 함수인 반면, 클래스형 컴포넌트는 render 메서드가 있는 `React.Component`를 상속 받아 구현하는 자바스크립트 클래스이기 때문이다.
- 함수형 컴포넌트는 useEffect 훅을 사용해 생명주기 메서드를 비슷하게 구현할 수 있다. 즉, useEffect는 생명주기를 위한 훅이 아니다. useEffect 컴포넌트의 state를 활용해 동기적으로 부수 효과를 만드는 메커니즘이다.

### 함수형 컴포넌트와 렌더링된 값

- 함수형 컴포넌트는 렌더링된 값을 고정하고, 클래스형 컴포넌트는 그렇지 못한다.
  - 클래스형 컴포넌트는 props의 값을 항상 this로부터 가져온다. 클래스형 컴포넌트의 props는 외부에서 변경되지 않는 이상 불변 값이지만 this가 가리키는 객체, 즉 컴포넌트의 인스턴스의 멤버는 변경 가능한(mutable) 값이다.
  - 클래스형 컴포넌트는 시작의 흐름에 따라 변화하는 this를 기준으로 렌더링이 일어난다.

# 2.4 렌더링은 어떻게 일어나는가?

리액트의 렌더링은 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정을 의미한다.

## **2.4.1 리액트의 렌더링이란?**

- 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다.

## **2.4.2 리액트의 렌더링이 일어나는 이유**

- 최초 렌더링
- 리렌더링
  - 클래스형 컴포넌트의 `setState`가 실행되는 경우
  - 클래스형 컴포넌트의 `forceUpdate`가 실행되는 경우
  - 함수형 컴포넌트의 `useState()`의 두 번째 배열 요소인 setter가 실행되는 경우
  - 함수형 컴포넌트의 `useReducer()`의 두 번째 배열 요소인 dispatch가 실행되는 경우
  - 컴포넌트의 key props가 변경되는 경우
    > key props: 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값
    > 동일한 자식 컴포넌트가 여러 개 있는 구조에서 리렌더링이 발생되면 current 트리와 worinInProgress 트리 사이에 어떠한 컴포넌트가 변경이 있었는지 구별해야 하는데, 이 두 트리 사이에 같은 컴포넌트인지를 구별하는 값이 바로 key다.

## **2.4.3 리액트의 렌더링 프로세스**

1. 렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.
2. 업데이트가 필요하다고 지정돼 있는 컴포넌트를 발견하면 클래스형 컴포넌트의 경우에는 `render()` 함수를 실행하게 되고, 함수형 컴포넌트의 경우에는 `FunctionComponent()` 그 자체를 호출한 뒤에, 그 결과물을 저장한다.
3. 각 컨포넌트의 렌더링 결과물을 수집한 다음, 리액트의 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 차례차례 수집한다. 이렇게 계산하는 과정을 리액트의 **재조정(Reconciliation)**이라고 한다.
4. 재조정 과정이 끝나면 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보이게 한다.

## **2.4.4 렌더와 커밋**

**렌더 단계(Render Phase)** : 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다.

- 렌더링 프로세스에서 컴포넌트를 실행해 이 결과와 이전 가상DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계다.
- 비교하는 것은 type, props, key다.

**커밋 단계(Commit Phase):** 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정

- 리액트가 먼저 DOM을 커밋 단계에서 업데이트한다면 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트한다.
- 리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 안다. 변경 사항을 계산했는데 아무런 변경 사항이 감지되지 않는다면 이 커밋 단계는 생략될 수 있다.

**동시성 렌더링 :** 의도된 우선순위로 컴포넌트를 렌더링해 최적화할 수 있는 비동기 렌더링.

- 렌더 단계가 비동기로 작동해 특정 렌더링의 우선순위를 낮추거나 필요하다면 중단하거나 재시작하거나, 경우에 따라서는 포기할 수 있다.

## **2.4.5 일반적인 렌더링 시나리오 살펴보기**

컴포넌트를 렌더링하는 작업은 별도로 렌더링으르 피하기 위한 조치가 돼 있지 않는 한 하위 모든 컴포넌트에 영향을 미친다. 그리고 부모가 변경됐다면 props가 변경됐는지와 상관없이 무조건 자식 컴포넌트도 리렌더링된다.

만약 자식 컴포넌트가 memo로 래핑되어 있다면 부모 컴포넌트에서 상태값이 변경됐음에도 렌더링이 일어나지 않는다. 즉 렌더 단계에서 컴포넌트 비교를 거쳤지만 memo로 선언한 덕분에 props가 변경되지 않으면 렌더링이 생략되므로 커밋 단계도 생략된 것이다.

# 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

## **2.5.1 주장 1: 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자**

- 대부분의 가벼운 작업 자체는 메모이제이션 보다는 매번 작업을 수행해 반환하는 것이 더 빠를 수도 있다.
- 메모이제이션은 항상 어느 정도의 트레이드 오프가 있는 기법이라고 보는 것이 옳다. 이전 결과를 캐시로 저장해 미래에 더 나은 성능을 위해 메모리를 차례대로 점유하게 된다. 렌더링도 비용이지만 메모리에 저장하는 것도 비용이다.

## **2.5.2 주장 2: 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해 버리자**

- memo를 컴포넌트의 사용에 따라 잘 살펴보고 일부에만 적용하는 방법
- memo를 일단 다 적용하는 방법

> 잘못된 memo로 지불해야 하는 비용은 바로 props에 대한 얕은 비교가 발생하면서 지불해야 하는 비용이다. 메모이제이션을 위해서는 CPU와 메모리를 사용해 이전 렌더링 결과물을 저장해 둬야 하고, 리렌더링할 필요가 없다면 이전 결과물을 사용해야 한다.
>
> 리액트는 이전 렌더링 결과를 다음 렌더링과 구별하기 위해 저장해 둬야 한다. 그것이 기본적인 리액트의 재조정 알고리즘이기 때문이다. 어차피 리액트의 기본적인 알고리즘 때문에 이전 결과물은 어떻게든 저장해두고 있다. 따라서 우리가 memo로 지불해야 하는 비용은 props에 대한 얕은 비교뿐인 것이다.

만약 memo를 하지 않았을 때 발생할 수 있는 문제

- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 그리고 위 두 가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
- 리액트가 구 트리와 신규 트리를 비교

리렌더링이 발생할 때 메모이제이션과 같은 별도 조치가 없다면 모든 객체는 재생성되고, 결과적으로 참조는 달라지게 된다. 이 달라진 참조에 대한 값을 어디서든 쓰지 않는다면 큰 문제가 되지 않을 수 있지만 이 값이 useEffect와 같은 의존성 배열에 쓰이게 된다면 변경된 참조로 인해 다른 쪽에도 영향을 미칠 것이다.

최적화에 대한 확신이 없다면 가능한 한 모든 곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.

## 2.5.3 결론 및 정리

리액트 파이버에서의 작동과 흐름을 살펴봤듯이 props에 대한 얕은 비교를 수행하는 것 보다 리액트 컴포넌트의 결과물을 다시 계산하고 실제 DOM까지 비교하는 작업이 더 무겁고 비싸다.
