# 03. 리액트 훅 깊게 살펴보기

함수형 컴포넌트가 상태를 사용하거나 클래스형 컴포넌트의 생명주기 메서드를 대체하는 등의 다양한 작업을 하기 위해 훅(hook)이라는 것이 추가됐다.

# 3.1 리액트의 모든 훅 파헤치기

## **3.1.1 useState**

useState는 함수형 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅이다.

### useState의 내부 구현

리액트는 클로저를 활용해서 state를 구현했다. 클로저를 사용함으로써 외부에 해당 값을 노출시키지 않고 오직 리액트에서만 쓸 수 있었고, 함수형 컴포넌트가 매번 실행되더라도 useState에서 이전의 값을 정확하게 꺼내 쓸 수 있게 됐다.

### 게으른 초기화

useState에 변수 대신 함수를 넘기는 것을 게으른 초기화(lazy initialization)라고 한다. 게으른 초기화는 useState의 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용하라고 권장된다. 이 게으른 초기화 함수는 오로지 state가 처음 만들어질 때만 사용된다. 만약 이후에 리렌더링이 발생된다면 이 함수의 실행은 무시된다.

- localStorage나 sessionStorage에 대한 접근, map, filter, find 같은 배열에 대한 접근, 혹은 초깃값 계산을 위해 함수 호출이 필요할 때와 같이 무거운 연산을 포함해 실행 비용이 많이 드는 경우에 게으른 초기화를 사용하는 것이 좋다.

## **3.1.2 useEffect**

useEffect는 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘이다. state와 props의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수라고 볼 수 있다.

### 클린업 함수의 목적

- 클린업 함수는 변경된 값을 읽는 것이 아니라 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행한다.
- 클린업 함수와 생명주기 메서드의 언마운트의 개념 차이
  - 클린업 함수는 언마운트라기보다는 함수형 컴포넌트가 리렌더링 됐을 때 의존성 변화가 있었을 당시 이전의 값을 기준으로 실행되는, 말 그대로 이전 상태를 청소해 주는 개념으로 보는 것이 옳다.

### 의존성 배열

```jsx
function Component() {
  console.log('렌더링됨');
}

function Component() {
  useEffect(() => {
    console.log('렌더링됨');
  });
}
```

- useEffect는 클라이언트 사이드에서 실행되는 것을 보장해 준다. useEffect 내부에서는 window 객체의 접근에 의존하는 코드를 사용해도 된다.
- useEffect는 컴포넌트 렌더링의 부수 효과, 즉 컴포넌트의 렌더링이 완료된 이후에 실행된다. 반면 직접 실행은 컴포넌트가 렌더링되는 도중에 실행된다. 따라서 서버 사이드 렌더링의 경우에 서버에서도 실행된다. 그리고 이 작업은 함수형 컴포넌트의 반환을 지연시키는 행위다.
- useEffect는 **컴포넌트가 렌더링된 후에** 어떠한 부수 효과를 일으키고 싶을 때 사용하는 훅이다.

### useEffect의 구현

핵심은 의존성 배열의 이전 값과 현재 값의 얕은 비교다. 리액트는 값을 비교할 때 Object.js를 기반으로 하는 얕은 비교를 수행한다. 이전 의존성 배열과 현재 의존성 배열의 값에 하나라도 변경 사항이 있다면 callback으로 선언한 부수 효과를 실행한다.

### useEffect를 사용할 때 주의할 점

- eslint-disable-line react-hooks/exhaustive-deps 주석은 최대한 자제하라
- 빈 배열 []을 의존성으로 할 때, 즉 컴포넌트를 마운트하는 시점에만 무언가를 하고 싶다라는 의도로 작성하곤 한다. 이는 클래스형 컴포넌트의 생명주기 메서드인 componentDidMount에 기반한 접근법으로, 가급적이면 사용해서는 안 된다.
- useEffect에 빈 배열을 넘기기 전에는 정말로 useEffect의 부수 효과가 컴포넌트의 상태와 별개로 작동해야만 하는지, 혹은 여기서 호출하는게 최선인지 한 번 더 검토해 봐야 한다.
- useEffect의 첫 번째 인수에 함수명을 부여하라. useEffect의 목적을 명확히 하고 그 책임을 최소한으로 좁힌다는 점에서 유용하다.
  ```jsx
  useEffect(
    function logActiveUser() {
      logging(user.id);
    },
    [user.id]
  );
  ```
- 거대한 useEffect를 만들지 마라
- 불필요한 외부 함수를 만들지 마라
  > useEffect의 콜백 인수로 비동기 함수를 바로 넣을 수 없는 이유?
  > state를 결과에 따라 업데이트하는 로직이 있다고 가정하면, 비동기 함수의 응답 속도에 따라 결과가 이상하게 나타날 수 있다. 이러한 문제를 useEffect의 경쟁 상태라고 한다.

## **3.1.3 useMemo**

useMemo는 비용이 큰 연산에 대한 결과를 저장(메모이제이션)해 두고, 이 저장된 값을 반환하는 훅이다. useMemo는 렌더링 발생 시 의존성 배열의 값이 변경되지 않았으면 함수를 재실행하지 않고 이전에 기억해 둔 해당 값을 반환하고, 의존성 배열의 값이 변경됐다면 첫 번째 인수의 함수를 실행한 후에 그 값을 반호나하고 그 값을 다시 기억해 둘 것이다.

## **3.1.4 useCallback**

useCallback은 인수로 넘겨받은 콜백 자체를 기억한다. 특정 함수를 새로 만들지 않고 다시 재사용한다.

## **3.1.5 useRef**

- useRef는 반환값이 객체 내부에 있는 current로 값에 접근 또는 변경할 수 있다.
- useRef는 그 값이 변하더라도 렌더링을 발생시키지 않는다. 개발자가 원하는 시점의 값을 렌더링에 영향을 미치지 않고 보관해두고 싶다면 useRef를 사용하는 것이 좋다.
