# 03. 리액트 훅 깊게 살펴보기

함수형 컴포넌트가 상태를 사용하거나 클래스형 컴포넌트의 생명주기 메서드를 대체하는 등의 다양한 작업을 하기 위해 훅(hook)이라는 것이 추가됐다.

# 3.1 리액트의 모든 훅 파헤치기

## **3.1.1 useState**

useState는 함수형 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅이다.

### useState의 내부 구현

리액트는 클로저를 활용해서 state를 구현했다. 클로저를 사용함으로써 외부에 해당 값을 노출시키지 않고 오직 리액트에서만 쓸 수 있었고, 함수형 컴포넌트가 매번 실행되더라도 useState에서 이전의 값을 정확하게 꺼내 쓸 수 있게 됐다.

### 게으른 초기화

useState에 변수 대신 함수를 넘기는 것을 게으른 초기화(lazy initialization)라고 한다. 게으른 초기화는 useState의 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용하라고 권장된다. 이 게으른 초기화 함수는 오로지 state가 처음 만들어질 때만 사용된다. 만약 이후에 리렌더링이 발생된다면 이 함수의 실행은 무시된다.

- localStorage나 sessionStorage에 대한 접근, map, filter, find 같은 배열에 대한 접근, 혹은 초깃값 계산을 위해 함수 호출이 필요할 때와 같이 무거운 연산을 포함해 실행 비용이 많이 드는 경우에 게으른 초기화를 사용하는 것이 좋다.

## **3.1.2 useEffect**

useEffect는 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘이다. state와 props의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수라고 볼 수 있다.

### 클린업 함수의 목적

- 클린업 함수는 변경된 값을 읽는 것이 아니라 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행한다.
- 클린업 함수와 생명주기 메서드의 언마운트의 개념 차이
  - 클린업 함수는 언마운트라기보다는 함수형 컴포넌트가 리렌더링 됐을 때 의존성 변화가 있었을 당시 이전의 값을 기준으로 실행되는, 말 그대로 이전 상태를 청소해 주는 개념으로 보는 것이 옳다.

### 의존성 배열

```jsx
function Component() {
  console.log('렌더링됨');
}

function Component() {
  useEffect(() => {
    console.log('렌더링됨');
  });
}
```

- useEffect는 클라이언트 사이드에서 실행되는 것을 보장해 준다. useEffect 내부에서는 window 객체의 접근에 의존하는 코드를 사용해도 된다.
- useEffect는 컴포넌트 렌더링의 부수 효과, 즉 컴포넌트의 렌더링이 완료된 이후에 실행된다. 반면 직접 실행은 컴포넌트가 렌더링되는 도중에 실행된다. 따라서 서버 사이드 렌더링의 경우에 서버에서도 실행된다. 그리고 이 작업은 함수형 컴포넌트의 반환을 지연시키는 행위다.
- useEffect는 **컴포넌트가 렌더링된 후에** 어떠한 부수 효과를 일으키고 싶을 때 사용하는 훅이다.

### useEffect의 구현

핵심은 의존성 배열의 이전 값과 현재 값의 얕은 비교다. 리액트는 값을 비교할 때 Object.js를 기반으로 하는 얕은 비교를 수행한다. 이전 의존성 배열과 현재 의존성 배열의 값에 하나라도 변경 사항이 있다면 callback으로 선언한 부수 효과를 실행한다.

### useEffect를 사용할 때 주의할 점

- eslint-disable-line react-hooks/exhaustive-deps 주석은 최대한 자제하라
- 빈 배열 []을 의존성으로 할 때, 즉 컴포넌트를 마운트하는 시점에만 무언가를 하고 싶다라는 의도로 작성하곤 한다. 이는 클래스형 컴포넌트의 생명주기 메서드인 componentDidMount에 기반한 접근법으로, 가급적이면 사용해서는 안 된다.
- useEffect에 빈 배열을 넘기기 전에는 정말로 useEffect의 부수 효과가 컴포넌트의 상태와 별개로 작동해야만 하는지, 혹은 여기서 호출하는게 최선인지 한 번 더 검토해 봐야 한다.
- useEffect의 첫 번째 인수에 함수명을 부여하라. useEffect의 목적을 명확히 하고 그 책임을 최소한으로 좁힌다는 점에서 유용하다.
  ```jsx
  useEffect(
    function logActiveUser() {
      logging(user.id);
    },
    [user.id]
  );
  ```
- 거대한 useEffect를 만들지 마라
- 불필요한 외부 함수를 만들지 마라
  > useEffect의 콜백 인수로 비동기 함수를 바로 넣을 수 없는 이유?
  > state를 결과에 따라 업데이트하는 로직이 있다고 가정하면, 비동기 함수의 응답 속도에 따라 결과가 이상하게 나타날 수 있다. 이러한 문제를 useEffect의 경쟁 상태라고 한다.

## **3.1.3 useMemo**

useMemo는 비용이 큰 연산에 대한 결과를 저장(메모이제이션)해 두고, 이 저장된 값을 반환하는 훅이다. useMemo는 렌더링 발생 시 의존성 배열의 값이 변경되지 않았으면 함수를 재실행하지 않고 이전에 기억해 둔 해당 값을 반환하고, 의존성 배열의 값이 변경됐다면 첫 번째 인수의 함수를 실행한 후에 그 값을 반호나하고 그 값을 다시 기억해 둘 것이다.

## **3.1.4 useCallback**

useCallback은 인수로 넘겨받은 콜백 자체를 기억한다. 특정 함수를 새로 만들지 않고 다시 재사용한다.

## **3.1.5 useRef**

- useRef는 반환값이 객체 내부에 있는 current로 값에 접근 또는 변경할 수 있다.
- useRef는 그 값이 변하더라도 렌더링을 발생시키지 않는다. 개발자가 원하는 시점의 값을 렌더링에 영향을 미치지 않고 보관해두고 싶다면 useRef를 사용하는 것이 좋다.

## 3.1.6 useContext

### context란?

props 내려주기를 극복하기 위해 등장한 개념

props driling: props를 하위 컴포넌트로 필요한 위치까지 계속해서 넘기는 기법.

### context를 함수형 컴포넌트에서 사용할 수 있게 해주는useContext 훅

### useContext를 사용할 때 주의할 점

- useContext를 함수형 컴포넌트 내부에서 사용할 때는 항상 컴포넌트 재활용이 어려워진다.
  - Provider 하위에 있지 않은 상태로 useContext를 사용한다면 예기치 못한 작동 방식이 만들어져 Provider에 의존성이 생기는 셈이다.
- useContext를 사용하는 컴포넌트를 최대한 작게 하거나 혹은 재사용되지 않을 만한 컴포넌트에서 사용해야 한다.
- **useContext는 상태를 주입해 주는 API다.**
  - 상태 관리 라이브러리가 되기 위한 조건
    - 어떠한 상태를 기반으로 다른 상태를 만들어 낼 수 있어야 한다.
    - 필요에 따라 이러한 상태 변화를 최적화 할 수 있어야 한다.
  - useContext API는 위의 조건들을 모두 만족하지 못한다.

## 3.1.7 useReducer

useState와 비슷하진 형태를 띠지만 좀 더 복잡한 상태값을 미리 정의해 놓은 시나리오에 따라 관리할 수 있다.

- state : 현재 useReduecer가 가지고 있는 값을 의미한다.
- dispatcher: state를 업데이트하는 함수. action(state를 변경할 수 있는 액션)을 넘겨준다.
- useReducer의 목적
  - state 값에 대한 접근은 컴포넌트에서만 가능하게 하고, 업데이트 하는 방법에 대한 상세 정의는 컴포넌트와 분리할 수 있게끔 함.
  - state 업데이트를 미리 정의해 둔 dispatcher로만 제한하기 때문

## 3.1.8 useImperativeHandle

### forwardRef 살펴보기

리액트에서 예약어로 지정된 ref 대신 다른 props로 ref를 받으면 잘 작동한다. forwardRef는 부모 컴포넌트에서 자식 컴포넌트로 ref를 전달할 때 사용하는 API다.

- ref를 전달하는데 일관성 제공하기 위함 (일관된 네이밍)

### useImperativeHandle이란?

useImperativeHandle은 부모에게서 넘겨받은 ref를 원하는 대로 수정할 수 있는 훅이다.

기존 `{current: <HTMLElement>}` 형식에서 useImperativeHandle 훅을 사용해서 추가적인 동작(값이나 액션)을 정의할 수 있다.

## 3.1.9 useLayoutEffect

> 이 함수의 시그니처는 useEffect와 동일하나, 모든 DOM의 변경 후에 동기적으로 발생한다.

- useEffect와 useLayoutEffect의 형태나 사용 예제는 동일하다.
- 리액트가 DOM을 업데이트 → useLayoutEffect를 실행 → 브라우저에 변경 사항을 반영 → useEffect를 실행
  - 동기적으로 발생한다는 것 : 리액트는 useLayoutEffect의 실행이 종료될 때까지 기다린 다음에 화면을 그리기 때문에 웹 애플리케이션 성능에 문제가 발생할 수 있다.
- DOM은 계산됐지만 이것이 화면에 반영되기 전에 하고 싶은 작업이 있을 때 사용하는 것이 좋다.

## 3.1.10 useDebugValue

리액트 애플리케이션을 개발하는 과정에서 사용되는데, 디버깅하고 싶은 정보를 이 훅에다 사용하면 리액트 개발자 도구에서 볼 수 있다.

오직 다른 훅 내부에서만 실행할 수 있다. 공통 훅을 제공하는 라이브러리나 대규모 웹 애플리케이션에서 디버깅 관련 정보를 제공하고 싶을 때 유용하게 사용할 수 있다.

## 3.1.11 훅의 규칙

훅의 사용 규칙 - 리액트 공식 문서

1. 최상위에서만 훅을 호출해야 한다. 반복문이나 조건문, 중첩된 함수 내에서 훅을 실행할 수 없다. 이 규칙을 따라야먄 컴포넌트가 렌더링될 때마다 항상 동일한 순서로 훅이 호출되는 것을 보장할 수 있다.
   1. 훅은 파이버 객체의 링크드 리스트의 호출 순서에 따라 저장된다. → 각 훅이 파이버 객체 내에서 순서에 의존해 state나 effect의 결과값을 저장하고 있기 때문이다.
   2. 순서에 의존해 훅과 관련된 정보를 저장함으로써 이전 값에 대한 비교와 실행이 가능해진다.
2. 훅을 호출할 수 있는 것은 리액트 함수형 컴포넌트, 혹은 사용자 정의 훅의 두 가지 경우뿐이다. 일반 자바스크립트 함수에서는 훅을 사용할 수 없다.

# 3.2 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

리액트에서 재사용할 수 있는 로직을 관리할 수 있는 두 가지 방법

- 사용자 정의 훅(custom hook)
- 고차 컴포넌트(higher order component)

## 3.2.1 사용자 정의 훅

- 리액트에서만 사용할 수 있는 방식이다.
- use로 시작하는 함수를 만들어야 한다. (리액트 훅의 규칙을 따라야한다.)
- 훅은 함수형 컴포넌트 내부 또는 사용자 정의 훅 내부에서만 사용할 수 있다.

## 3.2.2 고차 컴포넌트

고차 컴포넌트(HOC, Higher Order Component)는 컴포넌트 자체의 로직을 재사용하기 위함이다.

고차 컴포넌트는 고차 함수(Higher Order Function)의 일종이다.

### React.memo

리액트에서 제공하는 API로, 고차 컴포넌트이다.

리액트 컴포넌트는 부모 컴포넌트가 새롭게 렌더링 될 때 자식 컴포넌트의 props 변경 여부와 관계없이 발생한다. 이러한 props의 변화가 없음에도 리액트 렌더링을 방지하기 위해 만들어진 고차 컴포넌트가 React.memo다.

- React.memo는 이전 props와 같다면 메모이제이션된 컴포넌트를 반환한다.

```jsx
function ParentCompoent() {
  const MemoizedChildComponent = useMemo(() => {
    return <ChildComponent value='hello' />;
  }, []);

  return (
    <>
      <input type='number' value={state} />
      {MemoizedChildComponet}
    </>
  );
}
```

### 고차 함수 만들어보기

```jsx
function add(a) {
  return function (b) {
    return a + b;
  };
}

const result = add(1);
const rsult2 = result(2);
```

### 고차 함수를 활용한 리액트 고차 컴포넌트 만들어보기

```tsx
function withLoginComponet<T>(Component: ComponentType<T>) {
  return function (props: T & LoginProps) {
    const { loginRequired, ...restProps } = props;

    if (loginRequired) {
      return <>로그인이 필요합니다</>;
    }

    return <Component {...(restProps as T)} />;
  };
}
```

- with로 시작되는 이름을 사용해야 한다. (관습)
- 부수 효과를 최소화해야 한다.
  - 컴포넌트의 props를 임의로 수정, 추가, 삭제하는 일은 없어야 한다.
- 고차 컴포넌트는 최소한으로 사용하는 것이 좋다. 여러 개의 고차 컴포넌트로 컴포넌트를 감쌀 경우 복잡성이 커진다.

## 3.2.3 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

사용자 정의 훅과 고차 컴포넌트 모두 리액트 코드에서 로직을 공통화해 별도로 관리할 수 있다는 특징이 있다.

### 사용자 정의 훅이 필요한 경우

- 리액트에서 제공하는 훅으로만 공통 로직을 격리할 수 있다면 사용자 정의 훅을 사용하는 것이 좋다.
- 컴포넌트 내부에 미치는 영향을 최소화해 개발자가 훅을 원하는 방향으로만 사용할 수 있다는 장점이 있다.

### 고차 컴포넌트를 사용해야 하는 경우

- 렌더링의 결과물에 영향을 미치는 공통 로직이라면 고차 컴포넌트를 사용하는 것이 좋다.
- e.g.) PrivateRoute, Error Boundary
