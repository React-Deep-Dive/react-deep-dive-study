# 04. 서버 사이드 렌더링

# 4.1 서버 사이드 렌더링이란?

## 4.1.1 싱글 페이지 애플리케이션의 세상

### 싱글 페이지 애플리케이션이란?

- Single Page Application; SPA
- 렌더링과 라우팅에 필요한 대부분의 기능들을 브라우저의 자바스크립트에 의존하는 방식이다.
- 첫 페이지에서 데이터를 불러온 이후에는 페이지 전환을 위한 모든 작업이 브라우저의 `history.pushState`와 `history.replaceState`로 이루어진다.
- 비어있는 <body/> 태그 내부에 DOM을 추가, 수정, 삭제하는 방법으로 페이지를 전환한다.
- 최초에 로딩해야 할 자바스크립트 리소스가 커지는 단점이 있지만 한번 로딩된 이후에는 서버를 거쳐 필요한 리소스를 받아올 일이 적어지기 때문에 사용자에게 훌륭한 UI/UX를 제공한다는 장점이 있다.

### 전통적인 방식의 애플리케이션과 싱글 페이지 애플리케이션의 작동 비교

서버 사이드 렌더링 방식의 애플리케이션 페이지 전환이 발생할 때마다 새롭게 페이지를 요청하고, HTML 페이지를 다운로드해 파싱하는 작업을 거친다. 이 과정은 페이지를 처음부터 새로 그려야 해서 일부 사용자는 페이지가 전환될 때 부자연스러운 모습을 보게 된다.

SPA 에서는 페이지를 전환할 때 추가로 리소스를 다운로드하는 시간이 필요 없어진다.

### 싱글 페이지 렌더링 방식의 유행과 JAM 스택의 등장

- LAMP 스택
  - Linux(운영체제), Apache(서버), MySQL(epdlxjqpdltm), PHP/Python 등으로 구성
- JAM 스택
  - JavaScript, API, Markup
  - 대부분의 작업을 자바스크립트에서 수행할 수 있었기 때문에 서버 확장성 문제에서 좀 더 자유로워질 수 있게 됐다.

### 새로운 패러다임의 웹서비스를 향한 요구

자바스크립트 코드의 규모가 커짐에 따라 우려의 목소리와 함께, 웹페이지를 불러오는 데 필요한 부담을 일정 부분 사용자에게 전가하더라도 사용자의 기기나 인터넷 환경이 더 빠르게 발전할 것이기 때문에 괜찮을 것이란 기대감이 팽배했다.

웹 애플리케이션에서 제공하는 자바스크립트 리소스의 크기와 수가 모두 증가하기 시작했다. 평균 자바스크립트 리소스 크기는 지속적으로 우상향하고 있다.

자바스크립트 파싱을 위해 CPU를 소비하는 시간이 눈에 띄게 증가했으며, 사용자의 기기와 인터넷 속도 등 웹 전반을 다루는 환경이 크게 개선됐음에도 실제 사용자들이 느끼는 웹 애플리케이션의 로딩 속도는 크게 차이가 없거나 오히려 더 느리다.

웹 애플리케이션 개발자라면 이러한 웹 서비스 성능을 역행하는 추세에 책임감을 가질 필요가 있다.

### 4.1.2 서버 사이드 렌더링이란?

최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식을 의미한다.

웹페이지가 점점 느려지는 상황에 대한 문제의식을 싱글 페이지 애플리케이션의 한계에서 찾고, 이를 개선하고자 하는 방식이다.

싱글 페이지 애플리케이션

- 사용자에게 제공되는 자바스크립트 번들에서 렌더링을 담당
- 사용자 기기의 성능에 영향을 받는다

서버 사이드 렌더링

- 서버에서 페이지를 빌드
- 비교적 안정적인 렌더링이 가능하다.

### 서버 사이드 렌더링의 장점

1. 최초 페이지 진입이 비교적 빠르다.

- First Contentful Paint(페이지에 유의미한 정보가 그려지는 시간)이 더 발라질 수 있다.
- 서버가 사용자를 감당하지 못하고, 리소스를 확보하기 어렵다면 오히려 싱글 페이지 애플리케이션보다 느려질 수도 있다.

1. 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다.

- 검색 엔진이 사이트에서 필요한 정보를 가져가는 과정
  1. 검색 엔진 로봇(머신)이 페이지에 진입한다.
  2. 페이지가 HTML 정보를 제공해 로봇이 이 HTML을 다운로드한다. 단, 다운로드만 하고 자바스크립트 코드는 실행하지 않는다.
  3. 다운로드한 HTML 페이지 내부의 오픈 그래프(Open Graph)나 메타(meta) 태그 정보를 기반으로 페이지의 검색(공유) 정보를 가져오고 이를 바탕으로 검색 엔진에 저장한다.
- 검색 엔진에 제공할 정보를 서버에서 가공해서 HTML 응답으로 제공할 수 있으므로 검색 엔진 최적화에 대응하기가 매우 용이하다.

1. 누적 레이아웃 이동이 적다.

Cumulative Layout Shift (누적 레이아웃 이동)이란 사용자에게 페이지를 보여준 이후에 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 마치 화면이 덜컥거리는 것과 같은 부정적인 사용자 경험을 말한다.

1. 사용자의 디바이스 성능에 비교적 자유롭다.
2. 보안에 좀 더 안전하다.

서버 사이드 렌더링의 경우 인증 혹은 민감한 작업을 서버에서 수행하고 그 결과만 브라우저에 제공해 이러한 보안 위협을 피할 수 있다는 장점이 있다.

### 서버 사이드 렌더링의 단점

1. 소스코드를 작성할 때 항상 서버를 고려해야 한다.

- 브라우저 전역 객체인 window, sessionStorage에 접근하지 못한다.

1. 적절한 서버가 구축돼 있어야 한다.

- 사용자의 요청에 따라 적절하게 대응할 수 있는 물리적인 가용량을 확보해야 하고, 장애 상황에 대응할 수 있도록 복구 전략도 필요하다.

1. 서버 지연에 따른 문제

## 4.1.3 SPA와 SSR을 모두 알아야 하는 이유

### 서버 사이드 렌더링 역시 만능이 아니다

### 싱글 페이지 애플리케이션과 서버 사이드 렌더링 애플리케이션

### 현대의 서버 사이드 렌더링

최초 웹사이트 진입 시에는 서버 사이드 렌더링 방식으로 서버에서 완성된 HTML을 제공받고, 이후 라우팅에서는 서버에서 내려받은 자바스크립트를 바탕으로 마치 싱글 페이지 애플리케이션처럼 작동한다.

# 4.2 서버 사이드 렌더링을 위한 리액트 API 살펴보기

## 4.2.1 renderToString

인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수다.

- 리액트 컴포넌트를 기준으로 빠르게 브라우저가 렌더링할 수 있는 HTML을 제공하는 데 목적이 있는 함수이다. 즉, 클라이언트에서 실행되는 자바스크립트 코드를 포함시키거나 렌더링하는 역할까지 해주지는 않는다.

```
// data-reactroot는 리액트 컴포넌트의 루트 엘리먼트가 무엇인지 식별하는 역할을 한다.
// 이 속성은 hydrate 함수에서 루트를 식별하는 기준점이 된다.
<div id="root" data-reactroot="">
	<div>hello</div>
	<ul>
		<li>apple</li>
		<li›banana</li>
		<li>peach</li>
	</ul>
</div>
```

## 4.2.2 renderToStaticMarkup

`renderToString`과 리액트 컴포넌트를 기준으로 HTML 문자열을 만든다는 점에서 동일하다.

`data-reactroot와` 같은 리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않는다. → HTML의 크기를 줄일 수 있다는 장점이 있다.

hydrate를 수행하지 않는다는 가정하에 순수한 HTML을 반환할 때 사용된다.

## 4.2.3 renderToNodeStream

`renderToString`과 결과물은 완전히 동일하지만 두 가지 차이점이 있다.

1. `renderToStream`은 브라우저에서 사용하는 것이 완전히 불가능하다.

   `renderToStream`은 완전히 Node.js 환경에 의존한다.

2. 결과물의 타입이 다르다.

   `renderToString`은 string인 문자열이 반환되지만, `renderToNodeStream`은 utf-8로 인코딩된 바이트 스트림으로, Node.js 환경에서만 사용할 수 있다.

   **스트림 이해하기**

   > 유튜브와 같이 웹에서 동영상을 보는 상황을 상상해보자. 우리는 유튜브 영상을 보기 위해 전체 영상을 모두 다운로드할 때까지 기다리지 않는다. 사용자가 볼 수 있는 몇 초라도 먼저 다운로드되면 그 부분을 먼저 보여주고, 이후에 계속해서 영상을 다운로드한다. 스트림은 큰 데이터를 다룰 때 데이터를 청크(chunk, 작은 단위)로 분할해 조금씩 가져오는 방식을 의미한다.

   `renderToString`으로 생성해야 하는 HTML의 크기가 매우 클 때, 스트림을 활용하면 큰 크기의 데이털르 청크 단위로 분리해 순차적으로 처리할 수 있다는 장점이 있다.

## 4.2.4 renderToStaticNodeStream

`renderToNodeStream`과 제공하는 결과물은 동일하나, 자바스크립트에 필요한 리액트 속성이 제공되지 않는다. hydrate를 할 필요 없는 순수 HTML 결과물이 필요할 때 사용하는 메서드다.

## 4.2.5 hydrate

정적으로 생성된 HTML에 이벤트와 핸들러를 붙여 완전한 웹페이지 결과물을 만든다.

`render()` 함수와 비슷하지만, hydrate는 기본적으로 이미 렌더링된 HTML이 있다는 가정하에 작업이 수행되고, 이 렌더링된 HTML을 기준으로 이벤트를 붙이는 작업만 실행한다.

hydrate 작업은 단순히 이벤트나 핸들러를 추가하는 것 이외에도 렌더링을 한 번 수행하면서 hydrate가 수행한 렌더링 결과물 HTML과 인수로 넘겨받은 HTML을 비교하는 작업을 수행한다. 불일치가 발생하면 hydrate가 렌더링한 기준으로 웹페이지를 그리게 된다.

- 이렇게 렌더링을 하는 것은 서버와 클라이언트에서 두 번 렌더링을 하게 된다.

# 4.3 Next.js 톺아보기

## 4.3..1 Next.js란?

- PHP에 영감을 받아 만들어진 리액트 기반 서버 사이드 렌더링 프레임워크

## 4.3.2 Next.js 시작하기

### package.json

- eslint-config-next : 구글과 협업해 만든 핵심 웹 지표(core web cital)에 도움이 되는 규칙들이 내장되어 있다.

### next.config.js

```jsx
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
};

module.exports = nextConfig;
```

- reactStrictMode
- swcMinify: SWC를 기반으로 코드 최소화 작업을 할 것인지 여부를 설정하는 속성

> SWC : 바벨의 대안으로, 번들링과 컴파일을 더욱 빠르게 수행하기 위해 만들어졌다.
> Rust로 작성해 자바스크립트 기반의 바벨보다 빠르며, 병렬로 작업을 처리한다.

### pages/\_app.tsx

\_app.tsx, 그리고 내부에 있는 default export로 내보낸 함수는 애플리케이션의 전체 페이지의 시작점이다.

- 에러 바운더리를 사용해 애플리케이션 전역에서 발생하는 에러 처리
- reset.css 같은 전역 css 선언
- 모든 페이지에 공통으로 사용 또는 제공해야 하는 데이터 제공 등
- Next.js를 초기화하는 파일로, Next.js 설정과 관련된 코드를 모아두는 곳이며, 경우에 따라 서버와 클라이언트 모두에서 렌더링될 수 있다.

### pages/\_document.tsx

\_app.tsx가 애플리케이션 페이지 전체를 초기화하는 곳이라면, \_document.tsx는 애플리케이션의 HTML을 초기화하는 곳이다.

- \_app.tsx와의 차이점
  - <html>이나 <body>에 DOM 속성을 추가하고 싶다면 _document.tsx를 사용한다.
  - \_app.tsx는 렌더링이나 라우팅에 따라 서버나 클라이언트에서 실행될 수 있지만 \_document는 무조건 서버에서 실행된다.
  - Next.js에는 두 가지 <head>가 존재한다. 브라우저의 <head />와 동일한 역할을 한다.
    - next/document
      - document.tsx에서만 사용할 수 있다.
    - next/head
      - 페이지에서 사용할 수 있으며, SEO에 필요한 정보나 title 등을 담을 수 있다.

### pages/\_error.tsx

개발 모드에서는 이 페이지에 방문할 수 없다.

### pages/404.tsx

### pages/500.tsx

### pages/index.tsx

Next.js는 라우팅 구조는 /pages 디렉터리를 기초로 구성되며, 각 페이지에 있는 default export로 내보낸 함수가 해당 페이지의 루트 컴포넌트가 된다.

- `/pages/index.tsx`: 웹사이트의 루트이며, `localhost: 3000`과 같은 루트 주소를 의미한다.
- `/pages/hello.tsx`: /pages가 생략되고, 파일명이 주소가 된다. `localhost:3000/hello`
- `/pages/hello/workd.tsx`: `localhost:3000/hello/world`로 접근 가능하다.
- `/pages/hello/[greeting].tsx`: []의 의미는 어떠한 문자도 올 수 있다는 뜻이다.
- `/pages/hi/[…props].tsx`: /hi하위의 모든 주소가 여기로 온다.

### 서버 라우팅과 클라이언트 라우팅의 차이

Next.js는 서버 사이드 렌더링을 수행하지만 동시에 싱글 페이지 애플리케이션과 같이 클라이언트 라우팅 또한 수행한다.

Next.js는 서버 사이드 렌더링의 장점, 즉 사용자가 빠르게 볼 수 있는 최초 페이지를 제공한다는 점과 싱글 페이지 애플리케이션의 장점인 자연스러운 라우팅이라는 두 장점을 살리기 위한 방식으로 작동한다.

자연스러운 라우팅을 위한 규칙

- <a> 대신 <Link>를 사용한다.
- window.location.push 대신 router.push를 사용한다.

### 페이지에서 getServerSideProps를 제거하면 어떻게 될까?

- getServerSideProps가 있는 빌드
  - 서버 사이드 런타임 체크가 되어 있다.
- getServerSideProps가 없는 빌드
  - 서버 사이드 렌더링이 필요없는 정적인 페이지로 분류된다.
  - 이는 getServerSideProps가 없으면 서버에서 실행되지 않아도 되는 페이지로 처리하고 typeof window의 처리를 모두 object로 바꾼 다음, 빌드 시점에 미리 트리쉐이킹을 하기 때문이다.

### /pages/api/hello.ts

api 디렉터리는 서버의 api를 정의하는 폴더다. 기본적인 디렉터리에 따른 라우팅 구조는 페이지와 동일하되, /pages/api가 /api라는 접두사가 붙는 점만 다르다.

즉, /pages/api/hello.ts는 /api/hello로 호출할 수 있으며, 이 주소는 서버 요청을 주고 받게 된다.

서버에서 내려주는 데이터를 조합해 BFF(backend-for-frontend) 형태로 활용하거나, 완전한 풀스택 애플리케이션을 구축하고 싶을 때, 혹은 CORS(Cross-Origin Resource Sharing) 문제를 우회하기 위해 사용될 수 있다.

## 4.3.3 Data Fetching

Next.js에서는 서버 사이드 렌더링 지원을 위한 몇 가지 데이터 불러오기 전략을 뜻한다.

- pages/의 폴더에 있는 라우팅이 되는 파일에서만 사용할 수 있다.
- 예약어로 지정되어 반드시 정해진 함수명으로 export를 사용해 함수를 파일 외부로 내보내야 한다.
  - 이를 활용하면 서버에서 미리 필요한 페이지를 만들어서 제공하거나 해당 페이지에 요청이 있을 때마다 서버에서 데이터를 조회해서 미리 페이지를 만들어서 제공할 수 있다.

### getStaticPaths와 getStaticProps

- 어떠한 페이지를 CMS(Contents Management System)나 블로그, 게시판과 같이 사용자와 관계없이 정적으로 결정된 페이지를 보여주고자 할 때 사용되는 함수다.
- getStaticProps와 getStaticPaths는 반드시 함꼐 있어야 사용할 수 있다.
- 이 두 함수를 사용하면 빌드 시점에 미리 데이터를 불러온 다음에 정적인 HTML 페이지를 만들 수 있다.

### getServerSideProps

서버에서 실행되는 함수이며 해당 함수가 있다면 무조건 페이지 진입 전에 이 함수를 실행한다.

응답값에 따라 페이지의 루트 컴포넌트에 props를 반환할 수도, 혹은 다른 페이지로 리다이렉트시킬 수도 있다.

getServerSideProps의 반환 값을 기반으로 만든 HTML에는 NEXT_DATA\_\_라는 id가 지정된 script가 존재한다. 이 스크립트는 Next.js 구동에 필요한 다양한 정보가 담겨 있다. **이 정보는 왜 script 형태로 삽입돼 있을까?**

리액트의 서버 사이드 렌더링을 하는 작동

1. 서버에서 fetch 등으로 렌더링에 필요한 정보를 가져온다.
2. 1에서 가져온 정보를 기반으로 HTML을 완성한다.
3. 2번의 정보를 클라이언트(브라우저)에 제공한다.
4. 3번의 정보를 바탕으로 클라이언트에서 hydrate 작업을 한다. 이 작업은 DOM에 리액트 라이프사이클과 이벤트 핸들러를 추가하는 작업이다.
5. hydrate로 만든 리액트 컴포넌트 트리와 서버에서 만든 HTML이 다르다면 불일치 에러를 뱉는다.
6. 5번 작업도 1번과 마찬가지로 fetch 등을 이용해 정보를 가져와야 한다.

즉, 1번과 6번 작업 사이에 fetch 시점에 따라 결과물의 불일치가 발생할 수 있으므로 1번에서 가져온 정보를 결과물인 HTML에 script 형태로 내려주는 것이다. 이 작업을 거치면 1번의 작업을 6번에서 반복하지 않아도 되어 불필요한 요청을 막을 수 있고 시점 차이로 인한 결과물의 차이도 막을 수 있다.

getServerSideProps의 props로 내려줄 수 있는 값은 JSON으로 제공할 수 있는 값으로 제한된다. props의 결과를 HTML에 정적으로 작성해서 내려주기 때문에 JSON으로 직렬화할 수 없는 값, 즉 class나 Date 등은 props로 제공할 수 없다.

- getServerSideProps의 제약
  - window, document와 같이 브라우저에서만 접근할 수 있는 객체에는 접근할 수 없다.
  - API 호출 시 /api/some/path와 같이 protocol과 domain 없이 fetch 요청을 할 수 없다. 브라우저와 다르게 서버는 자신의 호스트를 유추할 수 없기 때문이다. 반드시 완전한 주소를 제공해야 fetch가 가능하다.
  - 여기서 에러가 발생한다면 500.tsx와 같이 미리 정의해 둔 에러 페이지로 리다이렉트된다.

사용자가 매 페이지를 호출할 때마다 실행되고, 이 실행이 끝나기 전까지는 사용자에게 어떠한 HTML도 보여줄 수 없다. 따라서 getServerSideProps 내부에 실행되는 내용은 최대한 간결하게 작성하는 것이 좋다.

### getInitialProps

getStaticProps나 getServerSideProps가 나오기 전에 사용할 수 있었던 유일한 페이지 불러오기 수단이었다.

getInitialProps는 라우팅에 따라서 서버와 클라이언트 모두에서 실행 가능한 메서드이다.

가급적이면 getStaticProps나 getServerSideProps를 사용하고, Nexxt.js의 특성상 사용이 제한돼 있는 페이지에서만 사용하는 것이 좋다.

## 4.3.4 스타일 적용하기

### 전역 스타일

\_app.tsx에 필요한 스타일을 직접 import로 불러오면 애플리케이션 전체에 영향을 미칠 수 있다.

### 컴포넌트 레벨 CSS

[name].module.css 명명 규칙을 준수해야 한다.

### SCSS와 SASS

### CSS-in-JS

기존에 기본적으로 내려주는 props에 추가적으로 styled-components가 모아둔 자바스크립트 파일 내 스타일을 반환한다.

리액트 트리 내부에서 사용하고 있는 styled-components의 스타일을 모두 모은 다음, 이 각각의 스타일에 유니크한 클래스명을 부여해 스타일이 충돌하지 않게 클래스명과 스타일을 정리해 이를 \_document.tsx가 서버에서 렌더링할 때 React.Context 형태로 제공한다.

이렇게 CSS-in-JS 스타일을 서버에서 미리 모은 다음 서버 사이드 렌더링에서 한꺼번에 제공해야 올바른 스타일을 적용할 수 있다.

## 4.3.5 \_app.tsx 응용하기

페이지 방문 최초 시점엔 서버 사이드 렌더링이 전체적으로 작동해야 해서 페이지 전체를 요청했다. 그러나 이후에는 클라이언트 라우팅을 수행하기 위해서 해당 페이지가 비록 getServerSideProps와 같은 서버 관련 로직이 있다 하더라도 전체 페이지를 가져오는 것이 아닌, 해당 페이지의 getServerSideProps 결과를 json 파일만을 요청해서 가져온다.

## 4.3.6 next.config.js 살펴보기

- basePath
- swcMinify: swc를 이용해 코드를 압축할지를 나타낸다.
- poweredByHeader: Next.js는 응답 헤더에 X-Power-by: Next.js 정보를 제공하는데, false를 선언하면 이 정보가 사라진다. 기본적으로 보안 관련 솔루션에서는 powered-by 헤더를 취약점으로 분류하므로 false로 설정하는 것이 좋다.
- redirects: 특정 주소를 다른 주소로 보내고 싶을 때 사용된다.
- reactStrictMode: 리액트에서 제공하는 엄격 모드를 설정할지 여부를 나타낸다.
- assetPrefix: 만약 next에서 빌드된 결과물을 동일한 호스트가 아닌 다른 CDN 등에 업로드하고자 한다면 이 옵션에 해당 CDN 주소를 명시하면 된다.
