# 10. 리액트 17과 18의 변경 사항 살펴보기

리액트를 사용하고 있는 사이트들은 일반적으로 16 버전을 사용중이라는 리포트가 존재한다. 그러나 이러한 사실이 리액트 16 버전으로 서비스하는 것이 충분하기 때문에 이후 버전인 17버전이나 18 버전을 이해할 필요가 없음을 의미하지는 않는다.

# 10.1 리액트 17 버전 살펴보기

16 버전과 다르게 새롭게 추가된 기능이 없으며 호환성이 깨지는 변경 사항, 즉 기존에 사용하던 코드의 수정을 필요로 하는 변경 사항을 최소화했다는 점이 큰 특징이다.

## 10.1.1 리액트의 점진적인 업그레이드

리액트는 유의적 버전을 기반으로 업데이트를 거치고 있다. 즉, 새로운 주 버전이 릴리즈되면 이전 버전에서의 API 제공을 완전히 중단해 버리고, 전체 애플리케이션을 새롭게 업그레이드를 요구하고 있었다.

17 버전부터는 점진적인 업그레이드가 가능해진다. ‘한 애플리케이션 내에 여러 버전의 리액트가 존재하는 시나리오’가 가능해진다.

하지만 리액트 팀에서는 여전히 리액트 버전을 한꺼번에 업데이트하는 게 복잡성 감소 측면에서 좋다고 언급했다.

## 10.1.2 이벤트 위임 방식의 변경

리액트에서 button의 onClick 이벤트를 부착하면 noop이라는 핸들러가 추가되어 있다.

- noop(no operation)은 아무런 일도 하지 않는다.
- 리액트는 이벤트 핸들러를 해당 이벤트 핸들러를 추가한 각각의 DOM 요소에 부탁하는 것이 아니라, 이벤트 타입(click, change) 당 하나의 핸들러를 루트에 부착한다. 이를 이벤트 위임이라고 한다.
  이벤트 위임
  1. 캡쳐(capture): 이벤트 핸들러가 트리 최상단 요소에서 부터 시작해서 실제 이벤트가 발생한 타깃 요소까지 내려가는 것을 의미한다.
  2. 타깃(target): 이벤트 핸들러가 타깃 노드에 도달하는 단계다. 이 단계예서 이벤트가 호출된다.
  3. 버블링(bubbling): 이벤트가 발생한 요소에서부터 시작해 최상위 요소까지 다시 올라간다.
- 리액트는 이벤트 위임을 적극적으로 활용해, 이벤트 핸들러를 각 요소가 아닌 document에 연결해서 이벤트를 효율적으로 관리한다.

이러한 이벤트 위임이 리액트 16 버전까지는 모두 document에서 수행되고 있었으나, 리액트 17부터는 리액트 컴포넌트 최상단 트리, 루트 요소로 바뀌었다.

- 점진적인 업그레이드 지원, 다른 바닐라 자바스크립트 코드 또는 jQuery 등이 혼재돼 있는 경우 혼란을 방지하기 위해서다.

```jsx
import React, { MouseEvent, useEffect } from 'reat';
import ReactDOM from 'react-dom';

export default function App() {
  useEffect(() => {
    document.addEventListener('click', (e) => {
      console.log('이벤트가 document까지 올라옴');
    });
  }, []);

  function 안녕하세요(e: MouseEvent<HTMLButtonElement>) {
    e.stopPropagation();
    alert('안녕하세요!');
  }

  return <button onClick={안녕하세요}>리액트 버튼</button>;
}

ReactDOM.render(<App />, document.getElementById('root'));
```

리액트 16에서는 모든 이벤트가 document에 달려 있으므로 stopPropagation이 의미가 없지만 리액트 17의 경우에는 컴포넌트 루트에 달려 있으므로 document에 부탁한 console 이벤트를 볼 수 없을 것이다.

## 10.1.3 import React from ‘react’가 더 이상 필요 없다: 새로운 JSX transform

JSX는 브라우저가 이해할 수 있는 코드가 아니므로 바벨이나 타입스크립트를 활용해 JSX를 실행하기 위해 일반적인 자바스크립트로 변환하는 과정이 꼭 필요하다. 16까지는 이러한 JSX 변환을 사용하기 위해 코드 내에서 `import React from ‘react’`가 필요했다.

그러나 리액트 17부터 바벨과 협력해 이러한 import 구문 없이도 JSX를 변환할 수 있게 됐다. 새로운 변환식은 불필요한 import 구문을 삭제해 번들링 크기를 약간 줄일 수 있다.

16버전에서는 React.createElement를 수행할 때 필요한 `import React from ‘react’`를 추가해주지 않는다. 17버전에서는 `require()` 구문이 추가된다. JSX를 변환할 때 필요한 모듈인 react/jsx-runtime을 불러오기 때문에 `import React from ‘react`’를 작성하지 않아도 된다.

## 10.1.4 그 밖의 변경 사항

### 이벤트 풀링 제거

리엑트에는 이벤트를 처리하기 위한 SyntheticEvent라는 이벤트가 있는데, 브라우저의 기본 이벤트를 한 번 더 감싼 이벤트 객체다. 리액트는 한번 래핑한 이벤트를 사용하기 때문에 이벤트가 발생할 때 마다 새로 객체를 생성했고, 메모리 할당 작업이 일어났다. 또한 메모리 누수를 방지하기 위해 이벤트를 주기적으로 해제해야 하는 번거로움도 있다. 이벤트 풀링이랑 SyntheticEvent 풀을 만들어서 이벤트가 발생할 때마다 가져오는 것을 의미한다.

1. 이벤트 핸들러가 이벤트를 발생시킨다.
2. 합성 이벤트 풀에서 합성 이벤트 객체에 대한 참조를 가져온다.
3. 이 이벤트 정보를 합성 이벤트 객체에 넣어준다.
4. 유저가 지정한 이벤트 리스너가 실행된다.
5. 이벤트 객체가 초기화되고 다시 이벤트 풀로 돌아간다.

한 번 이벤트 핸들러를 호출한 SyntheticEvent는 이후 재사용을 위해 null로 초기화된다. 따라서 비동기 코드 내부에서 SyntheticEvent인 e에 접근하면 이미 사용되고 초기화된 이후이기 때문에 null만 얻게 된다. 비동기 코드 내부에서 이 합성 이벤트 e에 접근하기 위해서는 추가적인 작업인 `e.persist()` 같은 처리가 필요했다.

비동기 코드로 이벤트 핸들러에 접근하기 위해서는 별도 메모리 공간에 합성 이벤트 객체를 할당해야 한다는 점, 그리고 모던 브라우저에서는 이와 같은 방식이 성능 향상에 크게 도움이 안 된다는 점 때문에 이벤트 풀링 개념이 삭제됐다.

### useEffect 클린업 함수의 비동기 실행

useEffect에 있는 클린업 함수는 리액트 16 버전까지는 동기적으로 처리됐다. 동기적으로 실행되기 때문에 이 클린업 함수가 완료되기 전까지는 다른 작업을 방해하므로 불필요한 성능 저하로 이어지는 문제가 존재했다.

리액트 17 버전부터는 화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행된다.

- 클린업 함수는 컴포넌트의 커밋 단계가 완료될 때까지 지연된다.
- 리렌더링이 일어난 뒤에 실행되어 화면에 업데이트가 반영되는 시간인 commitTime이 빨라진다.

### 컴포넌트의 undefined 반환에 대한 일관적인 처리

리액트 16과 17 버전은 컴포넌트 내부에서 undefined를 반환하면 오류가 발생한다. 이는 의도치 않게 잘못된 반환으로 인한 실수를 방지하기 위해서였다.

리액트 16에서는 forwardRef나 memo에서 undefined를 반환하는 경우에는 별다른 에러가 발생하지 않는 문제가 있었으나, 17에서는 정상적으로 에러가 발생한다. 18부터는 undefined를 반환해도 에러가 발생하지 않는다.

# 10.2 리액트 18 버전 살펴보기

- 동시성 지원

## 10.2.1 새로 추가된 훅 살펴보기

### useId

컴포넌트 별로 유니크한 값을 생성하는 훅이다. 클라이언트와 서버에서 불일치를 피하면서 컴포넌트 내부의 고유한 값을 생성할 수 있게 됐다.

### useTransition

UI 변경을 가로막지 않고 상태를 업데이트 할 수 있는 리액트 훅이다. 이를 활용하면 상태 업데이트를 긴급하지 않은 것으로 간주해 무거운 렌더링 작업을 조금 미룰 수 있으며, 사용자에게 조금 더 나은 사용자 경험을 제공할 수 있다.

리액트의 렌더링은 한 번 시작하면 멈출 수 없는 작업이기에 ,무거운 작업이 발생하고 이로 인해 렌더링이 가로막힐 여지가 있는 경우 useTransition을 사용하면 문제를 해결할 수 있다.

```jsx
export default function TabContaienr() {
	const [isPending, setIsTransition] = useTransition();
	const [tab, setTab] = useState<Tab>('about');

	function selectTab(nextTab: Tab) {
		startTransition(() => {
			startTab(nextTab)
		})
	}
	...
}
```

useTransition은 아무것도 인수로 받지 않으며, isPending과 startTransition이 담긴 배열을 반환한다.

- isPending : 상태 업데이트가 진행 중인지를 확인할 수 있는 boolean
- startTransition: 긴급하지 않은 상태 업데이트로 간주할 set 함수를 넣어둘 수 있는 함수를 인수로 받는다.

useTransition은 ‘동시성(concurrency)’을 다룰 수 있는 새로운 훅이다. 과거 리액트의 모든 렌더링은 동기적으로 작동해 느린 렌더링 작업이 있을 경우 애플리케이션 전체적으로 영향을 끼쳤지만 useTransition과 같은 동시성을 지원하는 기능을 사용하면 느린 렌더링 과정에서 로딩 화면을 보여주거나 혹은 지금 진행 중인 렌더링을 버리고 새로운 상태값으로 다시 렌더링하는 등의 작업을 할 수 있게 된다.

훅을 사용할 수 없는 상황이라면 startTransition을 바로 import 할 수 있다.

useTransition을 사용할 때의 주의할 점

- startTransition 내부는 반드시 setState와 같은 상태를 업데이트하는 함수와 관련된 작업만 넘길 수 있다. 만약 Props나 사용자 정의 훅에서 반환하는 값 등을 사용하고 싶다면 useDefferedValue를 사용할 수 있다.
- startTransition으로 넘겨주는 상태 업데이트는 다른 모든 상태 업데이트로 인해 실행이 지연될 수 있다. 예를 들어, 타이핑으로 인해 setState가 일어나는 경우 타이핑이 끝날 때까지 useTransition으로 지연시킨 상태 업데이트는 일어나지 않는다.
- startTransition으로 넘겨주는 함수는 반드시 동기 함수여야 한다. startTransition이 작업을 지연시키는 작업과 비동기로 함수가 실행되는 작업 사이에 불일치가 일어나기 때문이다.

### useDefferedValue

리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅이다.

디바운스와의 차이점

- 디바운스는 고정된 지연 시간을 필요로 하지만, useDefferedValue는 고정된 지연 시간 없이 첫 번째 렌더링이 완료된 이후에 이 useDefferedValue로 지연된 렌더링을 수행한다.
- 그러므로 이 지연된 렌더링은 중단할 수도 있으며, 사용자의 인터랙션을 차단하지도 않는다.

```jsx
export default function Input() {
	const [text, setText] = useState('')
	const deferredText = useDefferedValue(text)

	const list = useMemo(() => {
		const arr = Array.from({ length: deferredText.length }).map(
			(_) => deferredText,
		)

		return (
			<ul>
				{arr.map((str, index) => (
					<li key={index}>{str}<li>
				)}
			</ul>
		)
	}, [deferredText])
}
```

useDeferredValue와 useTransition의 차이점

- useTransition은 state 값을 업데이트하는 함수를 감싸서 사용하는 반면, useDeferredValue는 state 값 자체만을 감싸서 사용한다. 방식에만 차이가 있을 뿐, 지연된 렌더링을 한다는 점에서는 모두 동일한 역할을 한다.
- 만약 낮은 우선순위로 처리해야 할 작업에 대해 직접적으로 상태를 업데이트를 할 수 있는 코드에 접근할 수 있다면 useTransition을 사용하는 것이 좋다. 그러나 컴포넌트의 props와 같이 상태 업데이트에 관여할 수는 없고 오로지 값만 받아야 하는 상황이라면 useDeferredValue를 사용하는 것이 타당하다.

### useSyncExternalStore

- useSubscription의 구현이 리액트 18에 이르러서 useSyncExtenralStore로 대체된 것을 확인할 수 있다.

테어링(tearing)

- ‘찢어진다’라는 뜻으로, 하나의 state 값이 있음에도 서로 다른 값(보통 state나 props의 이전과 이후)을 기준으로 렌더링되는 현상을 말한다. 리액트 18에서는 렌더링을 일시 중지하거나 뒤로 미루는 등의 최적화가 가능해지면서 동시성 이슈가 발생할 수 있다.
  ![스크린샷 2024-03-23 오후 3.18.48.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/cba90d01-643e-4d54-9d61-bb5388038173/dd9e9a17-1280-4d66-9119-62fdf566eae8/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-03-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.18.48.png)
- 과거 리액트에서는 중간에 데이터 업데이트가 일어나는 것과 상관없이 동기적으로 렌더링이 한 번에 발생해서 이러한 문제가 없었다.
- 리액트에서 관리할 수 없는 외부 데이터 소스(글로벌 변수, document.body, window.innerWidth, DOM, 리액트 외부에 상태를 저장하는 외부 상태 관리 라이브러리)에서 동시성 처리가 추가돼 있지 않다면 테어링 현상이 발생할 수 있다. 그리고 이 문제를 해결하기 위한 훅이 useSyncExtenralStore다.

```jsx
import { useSyncExtenralStore } from 'react';

// useSyncExternalStore(
// subscribe: (callback) => Unsubscribe
// getSnapshot: () => State
//) => State
```

- 첫 번째 인수는 subscribe로, 콜백 함수를 받아 스토어에 등록하는 용도로 사용된다. 스토어에 있는 값이 변경되면 이 콜백이 호출돼야 한다. 그리고 useSyncExtenralStore는 이 훅을 사용하는 컴포넌트를 리렌더링한다.
- 두 번째 인수는 컴포넌트에 필요한 현재 스토어의 데이터를 반환하는 함수다. 이 함수는 스토어가 변경되지 않았다면 매번 함수를 호출할 때마다 동일한 값을 반환해야 한다. 스토어에서 값이 변경됐다면 이 값을 이전 값과 Object.is로 비교해 정말로 값이 변경됐다면 컴포넌트를 리렌더링한다.
- 마지막 인수는 옵셔널 값으로, 서버 사이드 렌더링 시에 내부 리액트를 하이드레이션하는 도중에만 사용된다.
- 외부에 상태가 있는 데이터에는 반드시 useSyncExtenralStore를 사용해 값을 가져와야 startTransition 등으로 인한 테어링 현상이 발생하지 않음을 알 수 있다.
- useSyncExtenralStore는 애플리케이션 코드에 직접적으로 사용할 일은 많지 않지만 사용 중인 관리 라이브러리가 외부에서 상태를 관리하고 있다면 이 useSyncExtenralStore를 통해 외부 데이터 소스의 변경을 추적하고 있는지 반드시 확인해야 한다.

### useInsertionEffect

CSS-in-js 라이브러리를 위한 훅이다.

CSS의 추가 및 수정은 브라우저에서 렌더링하는 작업 대부분을 다시 계산해 작업해야 하는데, 이는 리액트 관점으로 본다면 모든 리액트 컴포넌트에 영향을 미칠 수도 있는 매우 무거운 작업이다. 따라서 리액트 17과 styled-components에서는 클라이언트 렌더링 시에 이러한 작업이 발생하지 않도록 서버 사이드에서 스타일 코드를 삽입했다. 훅에서 이러한 작업을 할 수 있도록 도와주는 훅이 useInsertionEffect다.

useEffect와의 차이점

- useInsertionEffect는 DOM이 실제로 변경되기 전에 동기적으로 실행된다. 이 훅 내부에 스타일을 삽입하는 코드를 집어넣음으로써 브라우저가 레이아웃을 계산하기 전에 실행될 수 있게끔 해서 좀 더 자연스러운 스타일 삽입이 가능해진다.

useLayoutEffect와의 비교

- 두 훅 모두 브라우저에 DOM이 렌더링되기 전에 실행된다는 공통점이 있지만 useLayoutEffect는 모든 DOM의 변경 작업이 다 끝난 이후에 실행되는 반면 useInsertionEffect는 이러한 DOM 변경 작업 이전에 실행된다.
- useInsertionEffect는 라이브러리를 작성하는 경우가 아니라면 실제 애플리케이션 코드에는 가급적 사용하지 않는 것이 좋다.

## 10.2.2 react-dom/client

클라이언트에서 리액트를 만들 때 사용되는 API가 변경됐다.

### createRoot

기존의 react-dom에 있던 render 메서드를 대체할 새로운 메서드다.

### hydrateRoot

서버 사이드 렌더링 애플리케이션에서 하이드레이션을 하기 위한 새로운 메서드다. React DOM 서버 API와 함께 사용된다.

## 10.2.3 react-dom/server

### renderToPipeableStream

리액트 컴포넌트를 HTML로 렌더링하는 메서드다.

- 스트림을 지원한다. HTML을 점진적으로 렌더링하고 클라이언트에서는 중간에 script를 삽입하는 등의 작업을 할 수 있다.
- 서버에서는 Suspense를 사용해 빠르게 렌더링이 필요한 부분을 먼저 렌더링할 수 있고, 값비싼 연산으로 구성된 부분은 이후에 렌더링되게끔 할 수 있다. 최초에 브라우저는 아직 불러오지 못한 데이터 부분을 Suspense의 fallback으로 받는다.
- 기존 renderToNodeStream의 문제는 무조건 렌더링을 순서대로 해야 하고, 그 순서에 의존적이기 때문에 이전 렌더링이 완료되지 않는다면 이후 렌더링도 끝나지 않는다. 그러나 renderToPipeableStream을 활용하면 순서나 오래 걸리는 렌더링에 영향 받을 필요 없이 빠르게 렌더링을 수행할 수 있다.

### renderToReadableStream

renderToPipeableStream이 Node.js 환경에서의 렌더링을 위해 사용된다면, renderToReadableStream은 웹 스트림(web stream)을 기반으로 작동한다는 차이가 있다.

### 10.2.4 자동 배치(Automatic Batching)

리액트가 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법을 의미한다.

리액트 17이하의 과거 버전의 경우 이벤트 핸들러 내부에서는 자동 배치 작업이 이뤄지고 있었지만, Promise, setTimeout 같은 비동기 이벤트에서는 자동 배치가 이뤄지지 않았다. 이를 보안하기 위해 리액트 18 버전부터는 루트 컴포넌트를 createRoot를 사용해서 만들면 모든 업데이트가 배치 작업으로 최적화할 수 있게 됐다.

## 10.2.5 더욱 엄격해진 엄격 모드

### 리액트의 엄격 모드

리액트 애플리케이션에서 발생할 수도 있는 잠재적인 버그를 찾는데 도움이 되는 컴포넌트다. 개발자 모드에서만 작동하고, 프로덕션 모드에서는 작동하지 않는다.

### 더 이상 안전하지 않은 특정 생명주기를 사용하는 컴포넌트에 대한 경고

### 문자열 ref 사용 금지

- 문자열로 값을 주는 것은 여러 컴포넌트에 걸쳐 사용될 수 있으므로 충돌의 여지가 있다.
- 단순히 문자열로만 존재하기 때문에 실제로 어떤 ref에서 참조되고 있는지 파악하기 어렵다.
- 리액트가 계속해서 현재 렌더링되고 있는 컴포넌트의 ref 값을 추적해야 하기 때문에 성능 이슈가 있다.

### findDOMNode에 대한 경고 출력

클래스형 컴포넌트 인스턴스에서 실재 DOM 요소에 대한 참조를 가져올 수 있는 메서드다.

- findDOMNode를 사용하면 부모가 특정 자식만 별도로 렌더링하는 것이 가능해진다. 이는 리액트가 추구하는 트리 추상화 구조를 무너뜨린다.
- findDOMNode는 일회성 API라는 특징 때문에 자식 컴포넌트가 특정 시점에서 다른 노드를 렌더링 할 경우 이러한 변경 사항을 추적할 수 없다는 문제점이 있었다.

### 구 Context API 사용 시 발생하는 경고

### 예상치 못한 부작용(side-effects) 검사

리액트 엄격 모드 내부에서는 다음 내용을 의도적으로 이중으로 호출한다.

- 클래스형 컴포넌트의 constructor, rende, shouldComponentUpdate, getDerviedStateFromProps
- 클래스형 컴포넌트의 setState의 첫 번째 인수
- 함수형 컴포넌트의 body
- useState, useMemo, useReducer에 전달되는 함수

함수형 프로그래밍의 우너칙에 따라 리액트의 모든 컴포넌트는 항상 순수하다고 가정하기 때문이고, 항상 순수한 결과물을 내고 있는지 개발자에게 확인시켜 주기 위해 두 번 실행하게 되는 것이다.

### 리액트 18에서 추가된 엄격 모드

컴포넌트가 최초에 마운트될 때 자동으로 모든 컴포넌트를 마운트 해제하고 두 번째 마운트에서 이전 상태를 복원하게 된다.

## 10.2.6 Suspense 기능 강화

컴포넌트를 동적으로 가져올 수 있게 도와주는 기능이다.

React.lazy는 컴포넌트를 첫 번째 렌더링 시에 불러오지 않고, 최초 렌더링 이후에 컴포넌트를 지연시켜 불러오는 역할을 한다. Suspense는 React.lazy를 통해 지연시켜 불러온 컴포넌트를 렌더링하는 역할을 한다.

그러나 18 이전의 Suspense는 몇 가지 문제점이 있었다.

- 기존의 Suspenses는 컴포넌트가 아직 보이기도 전에 useEffect가 실행되는 문제가 존재했다.
- Suspense는 서버에서 사용할 수 없었다.

Suspense의 사용이 이전보다 비교적 자연스러워졌지만 여전히 Suspense를 사용시킬 수 있는 시나리오는 제한적인 편이다. 먼저 앞선 예제처럼 React.lazy를 사용해 컴포넌트를 지연시켜 불러오거나, 혹은 Next.js와 같이 Suspense를 자체적으로 지원하는 프레임워크에서만 Suspense를 사용하는 것이 가능하다.

### 10.2.7 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요

리액트를 사용하는 코드에서 다음과 같은 최신 자바스크립트 기능을 사용할 수 있다는 가정하에 배포된다.

- Promise
- Symbol
- Object.assign

리액트 뿐만 아니라 요즘 출시되는 대부분의 라이브러리가 ES5 지원을 중단하는 추세이기 때문에 만약 웹서비스가 여전히 인터넷 익스플로러 11을 지원해야 한다면 폴리필 설치 및 트랜스 파일에 각별히 신경 써야 한다.

### 10.2.8 그 밖에 알아두면 좋은 변경사항

- 컴포넌트에서 undefined를 반환해도 에러가 발생하지 않는다.
- renderToNodeStream이 지원 중단됐다. 그 대신 renderToPipeableStream을 사용하는 것이 권장된다.

## 10.2.9 정리

리액트 19 버전 업의 핵심은 동시성 렌더링이다.

- 과거 렌더링 과정은 중간에 일시 중지를 한다거나 렌더링 도중에 해당 렌더링 결과물을 포기한다든가 하는 메커니즘이 없었다.
- 렌더링 과정이 한층 복잡해졌지만 이 과정에서도 UI가 일관되게 표시할 수 있도록 보장한다.
