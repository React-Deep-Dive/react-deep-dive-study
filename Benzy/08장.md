# 08. 좋은 리액트 코드 작성을 위한 환경 구축하기

# 8.1 ESLint를 활용한 정적 코드 분석

버그와 예기치 못한 작동을 방지하기 위한 방법 중 하나이다. 정적 코드 분석이란 코드의 실행과는 별개로 코드 그 자체만으로 코드 스멜을 찾아내어 문제의 소지가 있는 코드를 사전에 수정하는 것을 의미한다.

## 8.1.1 ESLint 살펴보기

### ESLint는 어떻게 코드를 분석할까?

1. 자바스크립트 코드를 문자열로 읽는다.
2. 자바스크립트 코드를 분석할 수 있는 파서(parser)로 코드를 구조화한다.
3. 2번에서 구조화한 트리를 AST(Abstract Syntax Tree)라 하며, 이 구조화된 트리를 기준으로 각종 규칙과 대조한다.
4. 규칙과 대조했을 때 이를 위반한 코드를 알리거나(report) 수정한다(fix).

ESLInt는 자바스크립트를 분석하는 파서로 espree를 사용한다.

espree가 자바스크립트 파일을 구조화하는 방법

```jsx
function hello(str) {}
```

```jsx
{
	"type": "Program",
	"start": 0,
	"end": 22,
	"range": [0, 22],
	"body": [
		{
			"type": "FunctionDeclaration",
			"start": 0,
			"end": 22,
			"range": [0, 22],
			"id": {
				"type": "Identifier",
				"start": 9,
				"end": 14,
				"range": [9, 14],
				"name": "hello"
			},
			"expression": false,
			...
	}
}
```

타입스크립트의 경우도 @typescript-eslint/typescript-estree라고 하는 estree 기반 파서가 존재하며, 이를 통해 타입스크립트 코드를 분석해 구조화한다.

## 8.1.2 eslint-plugin과 eslint-config

- eslint-plugin
- eslint-config
  - eslint-config-airbnb
  - @titicaca/triple-config-kit
  - eslint-config-next

## 8.1.3 나만의 ESLint 규칙 만들기

### 이미 존재하는 규칙을 커스터마이징해서 적용하기 : import React를 제거하기 위한 ESLint 규칙 만들기

리액트 17 버전을 사용하고 있다면 Import React 구문을 모두 확인한 후에 제거하는 것이 좋다.

트리쉐이킹이 되지 않는 loadash 같은 라이브러리를 import 하는 것도 방지할 수 있다.

### 완전히 새로운 규칙 만들기: new Date를 금지시키는 규칙

자바스크립트 환경에서는 현재 시간을 알기 위해 사용하는 `new Date()`는 기기에 종속된 시간으로, 기기의 현재 시간을 바꿔버리면 `new Date()`가 반환되는 현재 시간 또한 변경된다.

## 8.1.4 주의할 점

### Prettier와의 충돌

### 규칙에 대한 예외 처리, 그리고 react-hooks/no-exhaustive-deps

`eslint-disable-line no-exhaustive-deps`

useEffect나 useMemo와 같이 의존 배열이 필요한 훅에 의존성 배열을 제대로 선언했는지 확인하는 역할을 한다. 임의로 판단해 없어도 괜찮다고 생각될 때 사용하는데, 잠재적인 버그를 야기할 수 있다.

- 괜찮다고 임의로 판단 경우: 해당 변수는 컴포넌트의 상태와 별개로 동작한다는 것을 의미한다.
- 의존성 배열이 너무 긴 경우: useEffect 내부 함수가 너무 길다는 말과 동일하다. useEffect를 쪼개서 의존성 배열의 가독성과 안정성을 확보해야 한다.
- 마운트 시점에 한 번만 실행하고 싶은 경우: 이러한 접근 방법은 과거 클래스형 컴포넌트에서 사용되던 생명주기 형태의 접근 방법으로, 함수형 컴포넌트의 패러다임과 맞지 않을 가능성이 있다. [] 배열이 있다는 것은 컴포넌트의 상태값과 별개의 부수 효과가 되어 컴포넌트의 상태와 불일치가 일어날 수 있게 된다. 마지막으로, 상태와 관계없이 한 번만 실행돼야 하는 것이 있다면 해당 컴포넌트에 존재할 이유가 없다.

### ESLint 버전 충돌

ESLint 공식 문서에서는 ESLInt를 peerDependencies로 설정해 두라고 권장하고 있다.

# 8.2 리액트 팀이 권장하는 리액트 테스트 라이브러리

**백엔드 테스트의 특징**

- 서버나 데이터베이스에서 원하는 데이터를 올바르게 가져올 수 있는지
- 데이터 수정 간 교착 상태나 경쟁 상태가 발생하지는 않는지
- 데이터 손실은 없는지
- 특정 상황에서 장애가 발생하지 않는지
- 화이트 박스 테스트, 작성한 코드가 의도대로 작동하는지 확인
- AUI(Application User Interface; 응용 프로그램 사용자 인터페이스)에서 주로 수행해야 하기 때문에 백엔드에 대한 이해가 있는 사람만 가능하다.

**프론트엔드 테스트의 특징**

- 일반적인 사용자와 동일하거나 유사한 환경에서 수행한다.
- 사용자가 프로그램에서 수행할 주요 비즈니스 로직이나 모든 경우의 수를 고려해야 한다.
- 블랙박스 형태의 테스트, 코드가 어떻게 됐든 상관없이 의도한 대로 작동하는지를 확인하는 데 초점이 맞춰져 있다.
- 프론트엔드는 사용자에게 완전히 노출된 영역이므로 어떻게 작동할지 최대한 예측해서 확인해야 한다.

## 8.2.1 React Testing Library

- DOM Testing Library를 기반으로 만들어진 테스팅 라이브러리
  - DOM Testing Libarary : jsdom을 기반으로 하고 있다.
  - jsdom이란 순수하게 자바스크립트로 작성된 라이브러리로, HTML이 없는 자바스크립트만 존재하는 환경(Node.js)에서 HTML과 DOM을 사용할 수 있도록 해주는 라이브러리다.
- 실제로 리액트 컴포넌트를 렌더링하지 않고도, 원하는 대로 렌더링되고 있는지 확인할 수 있다.

## 8.2.2 자바스크립트 테스트의 기초

작성한 코드가 예상대로 작동하는지 혹은 실패했는지를 알려주는 행위를 하는 라이브러리로 assert라는 모듈이 존재한다. 이처럼 테스트 결과를 확인할 수 있도록 도와주는 라이브러리를 어설션(assertion) 라이브러리라고 한다. 테스트 코드를 작성하는 개발자들은 이러한 어설션을 활용해 다양한 시나리오를 작성하고, 이 시나리오 상에서 코드가 올바르게 작동하는지 확인할 수 있다.

테스팅 프레임워크

- 좋은 테스트 코드는 다양한 테스트 코드가 작성되고 통과하는 것 뿐만 아니라 어던 테스트가 무엇을 테스트하는지 일목요연하게 보여주는 것이 중요하다.
- 어설션을 기반으로 테스트를 수행하며, 테스트 코드 작성자에게 도움이 될 만한 정보를 알려주는 역할을 함께 수행한다.
- Jest, Mocha, Karma, Jasmine
  - 메타에서 작성한 Jest가 널리 쓰이고 있다. 자체적으로 제작한 expect 패키지를 사용해 어설션을 수행한다.
- Jest를 비롯한 테스팅 프레임워크에는 이른바 글로벌(global)이라 해 실행 시에 전역 스코프에 기본적으로 넣어주는 값들이 존재한다. 이렇게 하면 테스트에 관한 정보를 임포트하지 않고도 사용할 수 있게 된다.

## 8.2.3 리액트 컴포넌트 테스트 코드 작성하기

1. 컴포넌트를 렌더링한다.
2. 필요하다면 컴포넌트에서 특정 액션을 수행한다.
3. 컴포넌트 렌더링과 2번의 액션을 통해 기대하는 결과와 실제 결과를 비교한다.

> 데이터셋

HTML의 특정 요소와 관련된 임의 정보를 추가할 수 있는 HTML 속성이다. HTML의 특정 요소에 data-로 시작하는 속성은 무엇이든 사용할 수 있다.

>

### 동적 컴포넌트

**사용자가 useState를 통해 입력을 변겅하는 컴포넌트**

**비동기 이벤트가 발생하는 컴포넌트**

MSW(Mock Service Worker)

Node.js나 브러우저에서 모두 사용할 수 있는 모킹 라이브러리로, 브라우저에서는 서비스 워커를 호라용해 실제 네트워크 요청을 가로채는 방식으로 모킹을 구현한다. 그리고 Node.js 환경에서는 https나 XMLHttpRequest의 요청을 가로채는 방식으로 작동한다.

## 8.2.4 사용자 정의 훅 테스트하기

react-hooks-testing-library

## 8.2.5 테스트를 작성하기에 앞서 고려해야 할 점

테스트 커버리지는 단순히 얼마나 많은 코드가 테스트되고 있는지를 나타내는 지표일 뿐, 테스트가 잘되고 있는지를 나타내는 것은 아니다. 그러므로 절대 테스트 커버리지를 맹신해서는 안된다.

프론트엔드 코드는 사용자의 입력이 매우 자유롭기 때문에 이러한 모든 상황을 커버해 테스트를 작성하기란 불가능하다. 때로는 테스트를 QA에 의존해 개발을 빠르게 진행해야 할 수도 있고, 이후에 또 개발해야 할 기능이 산적해 있을 수도 있다.

따라서 테스트 코드를 작성하기 전에 생각해 봐야 할 최우선 과제는 애플리케이션에서 가장 취약하거나 중요한 부분을 파악하는 것이다. 즉, 애플리케이션에서 가장 핵심이 되는 부분부터 먼저 테스트 코드를 하나씩 작성해 나가는 것이 중요하다.

테스트 코드는 개발자가 단순 코드 작성만으로는 쉽게 이룰 수 없는 목표인 소프트웨어 품질에 대한 확신을 얻기 위해 작성하는 것이다.

## 8.2.6 그 밖에 해볼 만한 여러 가지 테스트

- 유닛 테스트(Unit Test): 각각의 코드나 컴포넌트가 독립적으로 분리된 환경에서 의도된 대로 정확히 작동하는지 검증하는 테스트
- 통합 테스트(Integration Test): 유닛 테스트를 통과한 여러 컴포넌트가 묶여서 하나의 기능으로 정상적으로 작동하는지 확인하는 테스트
- 엔드 투 엔드 테스트(End to End Test): 흔히 E2E 테스트라 하며, 실제 사용자처럼 작동하는 로봇을 활용해 애플리케이션 전체적인 기능을 확인하는 테스트

## 8.2.7 정리

테스트가 이뤄야 할 목표 : 애플리케이션이 비즈니스 요구사항을 충족하는지 확인

- 의존해야 할 QA 여건이 부족한 상황
- 애플리케이션의 취약한 부분이 걱정되는 상황
