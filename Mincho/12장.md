# 모리딥 12장

# 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표

## 웹 사이트와 성능

웹사이트에 접속했을 때 공통적으로 기대하는 사항에는 다음과 같은 것들 있을 것이다.

1. 웹사이트를 방문한 목적을 손쉽게 달성할 수 있어야 한다.
2. 목적을 달성하는 데 걸리는 시간이 짧아야 한다.
3. 보안 정보 노출이 없어야 한다.

마케팅 에이전시 회사 Protent의 조사에 따르면 웹사이트 성능은 다음과 같은 요소에 영향을 미친다.

- 1초 내로 로딩되는 사이트는 5초 내로 로딩되는 사이트보다 거래 전환율이 2.5배 더 높다.
- 0 ~ 5초의 범위에서, 1초 로딩이 늦어질수록 전환율은 4.42%씩 떨어진다.
- 페이지 로드 시간이 0 ~ 2초 사이인 페이지에서 가장 높은 전환율을 달성했다.

또한 사용자가 민감하게 느끼는 부분은

- 소비자의 70%는 페이지 속도가 온라인 커머스 사이트를 방문하는 데 영향을 미친다고 밝혔다.
- 절반 가까운 사람이 더욱 빠르게 로딩할 수 있다면 애니메이션과 동영상이 필요 없다고 밝혔다.

구글에서도 웹사이트 성능에 관한 통계를 이렇게 내놓았다.

- 전체 웹페이지를 표시하는 데 필요한 최적의 평균 리소스 요청 수는 50회 미만이다. (한 페이지를 로딩하는데 50회 미만의 요청이 발생해야 한다.)
- 평균적으로 웹 페이지 전체를 요청하는 데 15.3초가 걸린다.
- 인간의 뇌와 신경계를 분석한 결과, 페이지 로드 시간이 1초에서 10초로 늘어날수록 모바일 사이트를 이탈할 확률이 123%증가한다.

## 핵심 웹 지표

구글에서 만든 지표로, 웹 사이트에서 뛰어난 사용자 경험을 제공하는 데 필수적인 지표를 일컫는 용어다.

- LCP(Largest Contentful Paint)
- FID(First Input Delay)
- CLS(Cumulative Layout Shfit)

핵심까지는 아니지만 특정 문제를 진단하는 데 사용되는 요소도 있다.

- TTFB(Time To First Byte)
- FCP(First Contentful Paint)

### LCP

페이지가 처음 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 콘텐츠(이미지, 텍스트)를 렌더링하는 데 걸리는 시간을 의미한다.

뷰포트, 즉 사용자에게 현재 노출되는 화면을 의미한다. 뷰포트는 사용자의 디바이스에 따라 당연히 달라진다. 사용자의 기기가 노출하는 뷰포트 내부에서 가장 큰 영역을 차지하는 요소가 렌더링되는 데 얼마나 걸리는지를 측정하는 지표이다.

사용자가 페이지가 어느 정도 로딩됐다고 인식하는 시점은 꼭 페이지가 완전히 로딩될 필요는 없다고 본다. 뷰포트에서 가장 큰영역인 메인 영역이 보이는 것에 있어서 페이지가 로딩이 완료됐다고 체감하는 시간과 매우 비슷하게 측정할 수 있을 것이다.

- 기준점수
  
![스크린샷 2024-03-26 오후 3 43 45](https://github.com/chhw130/reat-deep-dive-study/assets/116826162/b6d97851-5bca-4b44-a8c6-662f02bd90bd)


LCP는 해당 지표가 2.5초 이내에 응답이 온다면 Good, 4.0초면 보통 그 이후는 나쁨으로 판단한다.

- 개선하기

콘텐츠를 빠르게 로드하기 위해서는 어떤 것이 있을지 살펴보자.

1. 텍스트 사용
   뷰포트 내에 가장 큰 콘텐츠를 이미지가 아닌 텍스트 노출이 도움이 된다.
2. 이미지를 불러오는 방식
   이미지를 불러오는 방식에서도 큰 차이를 가져오게 된다.
   추가적으로 이미지 확장자명(jpg,png,webp,avif)등도 큰 영향을 미친다.
3. CDN서버 활용
   이미지가 크다면 CloudFlare와 같은 CDN서버를 이용해 받아오면 이미지를 최적화하고 가까운 서버에서 받아오기 때문에 해결책이 될 수 있다.

### FID

웹페이지 초기 로딩과 함께 사용자의 상호작용할 때 지연되는 속도를 의미한다. 트래픽이 몰린 사이트에 들어가게 되면 클릭 후 다음화면으로 이동한다던가, Input창에 입력하는데 지연되서 입력되는 경우가 그렇다.

이러한 문제가 발생하는 이유는 브라우저의 메인 스레드가 바쁘기 때문이다. 무언가 대규모 렌더링이 일어나고 있거나 처리해야하는 리소스를 해결하고 있기 때문이다. 이런 경우 Js(싱글스레드)는 다른 작업을 실행할 수 없어 지연이 일어난다.

구글은 이런 경험을 4가지로 분류해 정의한다. 이것을 `RAIL` 이라고 한다.

- Response : 사용자의 입력에 대한 반응 속도, 50ms미만으로 이벤트 처리하기
- Animation : 애니메이션 각 프레임을 10ms 이하로 생성할 것
- Idle : 유휴 시간을 극대화해 50ms이내에 사용자 입력에 응답
- Load : 5초 이내에 콘텐츠를 전달하고 인터랙션을 준비
  
![스크린샷 2024-03-26 오후 3 51 24](https://github.com/chhw130/reat-deep-dive-study/assets/116826162/c57a6edf-c2af-4531-98a1-3856d53936b1)



- 개선하기

1. 실행에 오래 걸리는 긴 작업 분리
   개발자의 최신 개발 기기에서도 오랜 시간이 소요되는 작업이라면 실제 사용자가 이용하는 경우에는 더욱 오래 걸릴 가능성이 높다. 만약 사용자의 기기의 환경과 비슷하게 메인 스레드의 성능을 의도적으로 낮추고 싶다면 크롬의 개발자 도구를 이용해 테스트할 수 있다.
2. 자바스크립트 코드 최소화
   현대의 번들링 도구들은 코드 번들리에 필요한 코드만 모아서 최종 프로덕션 자바스크립트 코드를 생성한다.
3. 타사 자바스크립트 코드 실행의 지연
   제3자가 만든 타사 스크립트가 있는 경우 메인 스레드가 잠시 점유되고, 이로 인해 사용자에게 안 좋은 반응성을 제공할수도 있다. script에서 async/defer 기능을 이용해 지연 불러오기를 하는 것이 좋다.

### CLS

웹 사이트에서 로딩이 끝난 줄 알고 무언가를 클릭하려고 했는데 그사이에 갑자기 다른 요소가 나오는 경우가 종종 있다. 이런 경험은 사용자에게 좋지 못한 경험을 가져다 준다. 이처럼 페이지의 생명주기 동안 발생하는 모든 예기치 못한 이동에 대한 지표를 계산하는 것이 CLS이다.

과거에는 서버단에서 정적으로 브라우저에 보여주곤 했지만, 현재 SPA앱들은 다양한 방법으로 동적으로 웹페이지를 보여주고 있다. 예를 들어 useEffect를 통해 동적으로 렌더링 이후 업데이트 된 값에 대해 UI를 업데이트 할 때가 그렇다.

- 개선하기

1.  삽입이 예상되는 요소를 위한 추가적인 공간 확보
    큰 누적 레이아웃 이동은 클라이언트에서 삽입되는 동적인 요소로 인해 발생한다. 이러한 것들은 사전에 방지하기 위해 useLayoutEffect를 사용해서 처리하는 편이 더 좋다. 또한 skeleton UI처럼 동적으로 어떤 콘텐츠가 뜰 지에 대해 안정적으로 보여줄 수도 있다.
2.  폰트 로딩 최적화
    폰트는 각각 고유의 높이와 너비를 가지고 있기 때문에 뷰포트에 따라서도 천차만별이다.

![스크린샷 2024-03-26 오후 4 04 14](https://github.com/chhw130/reat-deep-dive-study/assets/116826162/63ae05de-2c7d-4336-9683-af6fe4c2cac7)


        폰트로 발생할 수 있는 문제는 크게 두가지다.

        - FOUT(flash of unstyled text) : HTML문서에 지정한 폰트가 아닌 기본 폰트로 보이다가 뒤늦게 폰트가 적용되는 현상
        - FOIT(flash of invisible text) : HTML 문서에서 지정한 폰트가 보이지 않고, 기본 폰트도 없어서 텍스트가 없는 채로 있다가 폰트가 뒤늦게 로드되는 현상

### TTFB(Time To First Byte)

브라우저가 웹페이지의 첫 번째 바이트를 수신하는 데 걸리는 시간을 의미한다. 즉, 최초의 응답이 오는 바이트까지가 얼마나 걸리는지를 측정하는 지표다. 600ms이상 걸릴 경우 개선이 필요하다고 간주된다.

이는 서버 사이드 렌더링을 하고 있는 애플리케이션에서 주의할 필요가 있다. 대체로 정적인 지원을 제공하는 페이지는 서버에서 어느 정도 작업을 수행해야 한다. 서버에서 HTML을 만들기 위해 작업이 커질수록 최초 바이트까지의 시간이 길어진다.

- 서버 사이드 렌더링을 수행하고 있다면
  로직을 최적화해 페이지를 최대한 빨리 준비시켜야 한다. API호출을 하고 있다면 API호출 또한 최적화할 필요가 있다. 호출 횟수와 가져오는 정보의 크기를 최소화해서 최대한 API응답 속도를 빠르게 하고 크기를 줄여야 한다.
- 웹페이지의 주된 방문객의 국적과 서버를 가깝게 하기

### FCP(First Contentful Paint)

페이지가 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 화면에 렌더링될 때까지의 시간을 측정한다.
